<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>书籍</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="书籍"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-08-10 09:56:18 CST"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">书籍</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 book</a>
<ul>
<li><a href="#sec-1-1">1.1 结构化计算机组成 by Andrew.S.Tanenbaum</a></li>
<li><a href="#sec-1-2">1.2 现代操作系统 by Andrew.S.Tanenbaum</a></li>
<li><a href="#sec-1-3">1.3 本福德定律(Benford’s Law)</a></li>
<li><a href="#sec-1-4">1.4 in-house programmer</a></li>
<li><a href="#sec-1-5">1.5 使用Tex撰写文档</a></li>
<li><a href="#sec-1-6">1.6 计算机系统概率 by Yale N.Patt</a></li>
<li><a href="#sec-1-7">1.7 重构-改善既有代码的设计</a></li>
<li><a href="#sec-1-8">1.8 虚拟机设计与实现</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> book</h2>
<div class="outline-text-2" id="text-1">



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 结构化计算机组成 by Andrew.S.Tanenbaum</h3>
<div class="outline-text-3" id="text-1-1">

<p>然而这只是理想情况。我们必须面对严酷的现实。当一种新型计算机出现的时候，所有潜在的购买者要问的第一个问题是：“他和以前的型号兼容吗？”第二问题是：“我能够在上面运行我现有的操作系统吗？”第三个问题是：“它能够不加修改就运行我现有的应用程序吗？”。如果这些问题的任何一个答案是“不能”，那么设计者就必须去做大量的解释工作。因为计算机的购买者很少愿意扔掉他们的所有旧软件而重新购买新的。
</p>
<p>
怎样才能设计出一个好的指令系统层呢？有两个主要因素:
</p><ul>
<li>首先一个好的指令系统层应该定一套和将来的技术条件下能够高效率实现的指令集。这样可以使高效率的设计应用于今后的若干代计算机中。设计得不好的指令系统层实现起来比较困难，而且可能需要更多的逻辑门来实现处理器和更多的内存来执行程序。因为减少了重叠操作的机会，可还可能运行起来比较缓慢，这样既需要进行更复杂的设计来获得与一个设计得好的指令系统相同的性能。如果一个指令系统曾使用一种极为特殊的技术来实现高效率的设计，一般来说它只能用在某一代计算机中。它就像是一道闪电，虽然耀眼，但是不久就会被更加有预见性的设计所取代。
</li>
<li>其次，一个好的指令系统层应该为编译器提供明确的编译目标。编译结果的规律性和完整性是指令系统层中重要的特性。然而，并不是每一个指令系统层都做到了这一点。这些属性对于编译器来说是重要的，编译器在有限选择种选择最佳方案时经常会遇到困难，尤其是当某些显而易见的选择被指令系统层禁止的时候。简而言之，由于指令曾是硬件和软件之间的接口，它应该使硬件设计者和软件设计者都满意。对于硬件设计者来说，它很容易高效率实现，对于软件设计者来说，可以很容易地为它生成代码。
</li>
</ul>


<p>
我们要说明的是现在计算机的核心是深度流水线的三寄存器存取RISC引擎，UltraSPARC简单的把引擎暴露在用户面前，Pentium II通过采用老的指令系统层外壳把这一引擎隐藏起来，而在内部通过把CISC指令划分成等价的RISC微操作来获得高的执行效率。PicoJava II也把RISC引擎隐藏在内部，但和Pentium II相反，它是把多条指令系统层指令组合成一条RISC指令来完成。如果花仙子在森林中偶然碰到了一些计算机指令，它会发现一些指令太大了(Pentium II指令必须被分裂），有些又太小了（PicoJava II指令必须被组合执行），还有一些正好(UltraSPARC指令集),这就是计算机科学的三只熊理论.
</p>
<p>
使用EPIC(Explicitly Parallel Instruction Computing)计算模式的IA-64体系结构是我们可以很容易的开发程序的并行性，它还使用了判定和预取技术来加快执行速度。总而言之，相对于Pentium II而言，这是一个显著的进步，但是为了充分发挥其能力，需要编写能进行并行优化的编译器，这是一个相当沉重的负担。
</p>
<p>
在四个方面需要我们使用汇编语言
</p><ul>
<li>由于一个大项目成败的关键往往在于某些关键代码短的性能能否在提高2-3倍，这时候需要汇编编写关键代码
</li>
<li>某些情况下，由于缺乏内存，使用汇编语言可能是唯一的办法，比如一些嵌入式的应用，例如智能卡中的程序，蜂窝电话中的程序，设备驱动程序，BIOS程序和关键性能饮用的内部循环程序
</li>
<li>编译器必须能够产生共汇编器使用的汇编程序或者自己执行汇编过程。因为为了理解编译器的工作原理，必须首先理解汇编语言。因为编译器和汇编器毕竟也是人编写的
</li>
<li>研究会汇编语言可以使我们看清楚实际计算机的结构，对于学习计算机体系结构的学生，编写汇编语言是在体系结构层理解计算机的唯一途径
</li>
</ul>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 现代操作系统 by Andrew.S.Tanenbaum</h3>
<div class="outline-text-3" id="text-1-2">

<p>Unix的最基本的方针
</p><ol>
<li>所有的东西都是文件
</li>
<li>每个程序都应该只做一件事情，并且要做好。
</li>
</ol>

<p>程序员需要计算机是仆人而不是保姆。
</p>
<p>
Unix实用程序分为6大类
</p><ul>
<li>文件和目录管理命令
</li>
<li>过滤器
</li>
<li>程序开发工具如编辑器和编译器
</li>
<li>文本处理
</li>
<li>系统管理
</li>
<li>杂项
</li>
</ul>

<p>POSIX标准为100多个实用程序制定了语法和语义，主要是针对前三类程序。标准化这些实用程序思想是使人核能都能够编写shell脚本，并且使用这些程序能在所有的Unix系统里面运行。
</p>
<p>
抽象很重要，同时需要兼顾效率.微软公司清醒地认识到这一点，并尝试做一个很小的底层，以隐藏不同机器之间的差异，这一层被称为硬件抽象层(Hardware Abstraction Layer,HAL).谣传这个名字是IBM每个字母减1的结果HAL的作用是将操作系统的其余部分表示为抽象的硬件设备，特别是去除了真正硬件所附函的瑕疵和特质。这些设备表现为操作系统的其他部分和设备可以使用的独立与机器的服务和形式(函数调用和宏)。通过使用HAL服务和间接硬件寻址，当移植到新的硬件上时，驱动程序和核心秩序作很少的改动。移植HAL本身是直接的，因为所有的机器相关的代码都集中到一个地方，并且移植的目标是充分定义的，即实现所有的HAL服务。尽管HAL已经相当高效，但是对于多媒体应用而言，它的速度可能还不够快。为此，微软公司另外直接提供了一个名为DirectX的软件包，它用附加的过程增强了HAL，并允许用户进程对硬件进行直接的访问。一个操作系统最重要但可能最困难的任务是定义正确的抽象概念。有一些抽象概念，例如进程和文件，已经存在多年似乎显而易见。其他一些抽象概念，例如线程还比较新鲜，就不是那么成熟了。
</p>
<p>
接口设计的原则：
</p><ol>
<li>简单 不是有东西可以在添加，而是没有东西可以再裁减时，才能达到尽善尽美。
</li>
<li>完备 万事都应该尽可能的简单，但不能过于简单。首先，重要的是强调简单和精炼的价值，因为复杂容易导致增加困难并且产生错误，正如我们已经看到的那样。我对精炼的定义是以机制的最少化和清晰度的最大化实现指定的功能。
</li>
<li>效率
</li>
</ol>


<p>
添加更多的代码就是添加更多的程序错误。
</p>
<p>
对于性能优化的一条相当适用的口号是：“足够好才是足够好。”通过这条口号我们表达的意思是：性能一旦达到一个合理的水平，榨取最后一点百分比的努力和复杂性或许并不值得。如果调度算法相当公平并且在90%时间内保持CPU忙碌，它就尽到了自己的职责。发明一个改进了5%但是要复杂得多的算法或许是一个坏主意。
</p>
<p>
程序员是天生的乐观主义者。他们中的大多数人为编写程序的方式就是急切地奔向键盘并且开始击键，不久以后完全调试好的程序就完成了。然而对于大型程序，事实并非如此。
</p>
<p>
对于人员与时间的权衡，Brooks在他的《人月神话》中将他的经验总结在Brooks定律中：“对于一个延期的软件项目，增加人力将使他更加延期。”用稍微有意思的方法阐述就是“无论分配多少妇女从事这一工作，生一个孩子都需要9个月”。
</p>
<p>
任何大型的设计项目中包括软件和其他工程，最重要的是需要体系结构的一致性。应该有一名才智超群的人对设计进行控制。Brooks引证了兰斯大教堂作为大型项目的例子。兰斯大教堂的建造花费了几十年的时间，在这一过程中，后来的建筑师完全服从于完成最初建筑师的规划，结果是其他欧洲大教堂无可比拟的建筑构造的一致性。值得注意的是，最为成功的开放源代码项目显然是用了首席程序员模式，有一名才智超群者控制着体系结构的设计，Linus Torvalds控制着Linux内核，Richard Stallman控制着GNU C编译器。
</p>
<p>
拥有丰富经验的设计人鱼对于一个操作系统来说至关重要。大多数程序错误不是在代码中，而是在设计中。程序员正确作了吩咐他们要所的事情，而吩咐他们要做的事情是错误的。再多的测试软件都无法弥补糟糕的设计说明书。
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 本福德定律(Benford’s Law)</h3>
<div class="outline-text-3" id="text-1-3">

<p>Pick a random financial transaction from the ledger of a typical business and there is about a 30% chance that the first non-zero digit of the amount of money involved is a 1. This counter-intuitive fact is a result of Benford’s Law, discovered by astronomer Simon Newcomb in the late 1800′s and rediscovered by physicist Frank Benford in the early 1900′s. They found that real world data are not evenly distributed. Instead, given a random number related to some natural or social phenomenon satisfying certain conditions, the probability that the first non-zero digit of the number is D is log10(1 + 1/D).
从随机的金融交易涉及的金额来看，有30%的几率第一位非零数字是1。这个违反直觉的定律就是本福德定律(Benford’s Law).他们发现世界上存在的数字并不是均匀分布的，在满足一定条件下的自然或者是社会现象涉及到的数字，第一个非零数字为D的几率为log10(1 + 1/D).
</p>
<p>
Increasingly, financial auditors are using Benford’s Law to detect possible fraud. Given a record of the financial transactions of a company, if some leading digit appears with a frequency that significantly differs from that predicted by Benford’s Law, it is a signal that those transactions deserve a closer look.
使用上面本福德定律(Benford’s Law)我们就可以检测一些可能的欺诈。给定一个公司关于金融交易记录，如果交易记录的涉及金额第一位非零数字不满足本福德定律(Benford’s Law)的话，那么很可能说明记录中存在欺诈而值得进一步的调查。
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> in-house programmer</h3>
<div class="outline-text-3" id="text-1-4">

<p>毕业以后，Joel先在微软公司干了一段日子，然后回到纽约，进入维亚康母公司[Viacom]，为这家巨型的娱乐传播公司编写软件，成为IT部门里一个程序员[in-house programmer]。后来，Joel回忆起来，认为这是他一生中最痛苦的日子，并且劝告计算机系的学生尽可能不要去做”in-house programmer”。原因有三个:
</p><ol>
<li>首先，你永远没有办法正确地编写软件，你不得不用最方便的方法编写软件。因为软件支出非常高昂，所以公司会要求尽可能节省成本，你不可能试用新技术，只能使用现有的最成熟、最保守的技术。
</li>
<li>其次，你没有办法将一个项目做到尽善尽美。一旦程序可以正常运行，你的工作也就结束了，可以接下去干公司的下一个项目了。你的作用是解决问题，而不是将软件写得尽可能好。如果你是在一个专业的技术性公司，比如Google或Facebook，情况就完全不一样，你的软件写得越好，公司就会越成功，所以公司会支持你在一个项目上不断做下去。
</li>
<li>最后，传统公司IT部门里的程序员，只属于公司内部的维护人员，而不是直接从事核心业务的人员。因此，你永远办法进入管理层。但是，在技术性公司，程序员会变成CEO。
</li>
</ol>

<p>不幸的是，80%的程序员属于这一类，年复一年，很多人的生命就是这样被耗干的。[it’s frightening because this is what probably 80% of programming jobs are like, and if you’re not very, very careful when you graduate, you might find yourself working on in-house software, by accident, and let me tell you, it can drain the life out of you&hellip;]
</p>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 使用Tex撰写文档</h3>
<div class="outline-text-3" id="text-1-5">

<p>标记描述系统分为3种：
</p><ol>
<li>Visual MarkUp System.But Visual MarkUp systems focus attention on appearance,not content.Like WinWord We usually use.（这就是我感触最深的一句话。作为一个写论文的学生，你应该关注的更多的应该是文章的内容而不应该是appearance of the paper.但是没有办法，周围人都在使用Word，所以两者都还是要学习的。）
</li>
<li>Procedural Markup programs such as TEX,and Unix Based nroff and troff.They require user to type procedure command codes for vitually all aspects of document production.This include steps as explicit as defining how much space will appear between lines and paragraphs.etc（过程化标记语言）
</li>
<li>Descriptive markup systems. also require users to type formatting comomands into the body of a document’s computer file.Unlike procedural markup system.However,descriptive systems focus the user’s attention on document content rather appearance by having the user type coomands that describe what’s being types,instead of how the text should appear in printed form.Such as LaTEX（描述式标记语言）
</li>
</ol>


</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 计算机系统概率 by Yale N.Patt</h3>
<div class="outline-text-3" id="text-1-6">

<p>抽象的理念.当设计一个由各种门电路组成的逻辑电路时，千万不要陷入门电路的内部原理，这会大大拖延设计的进度。你应该将其中每个门电路都看作是现成的，可靠的，而仅当电路不工作的时候，才去研究门电路内部结构，这样才能发现问题所在。再如你设计一个复杂的计算机应用程序如电子表格，你可以将使用到的每个组建看作是一个抽象，研究每个组件的实现细节是毫无意义的，那只会让你的工作永远无法结束。当系统出现问题的时候，想发现问题所在就必须深入组建的内部机制。实际上意味着，我们既要不断提高抽象层次，又要注重细节的深入.
</p>
<p>
软件和硬件.我们相信，不管你的未来职业趋向是计算机软件还是硬件，两者都懂必然会使你更强。面对大多数问题，如果解题者具备软硬件两方面的知识，那么他或她给出的答案会更漂亮
</p>
</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> 重构-改善既有代码的设计</h3>
<div class="outline-text-3" id="text-1-7">

<p>重构是这样一个过程：“再不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构.重构是一种有纪律的，经过训练的，有条不紊的程序整理方法，可以将整理过程中不小心引入错误的几率降到最低。本质上说，重构就是在代码写好之后改进它的设计.什么时候进行重构?如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便做的时候，那么就先重构那个程序，使特性的添加比较容易进行，然后再添加特性.重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验的能力(self-checking)
</p>
<p>
任何一个傻瓜都能写出计算机可以理解的代码。惟有写出人类容易理解的代码才是优秀的程序员（或许优秀的程序员还要精通英语，不然怎么写出所有人类容易理解的代码，或许像我英语这么差的人，一辈子都不能成为优秀程序员）
</p>
<p>
当然，很多经理嘴巴上说自己质量驱动，其实更多的是进度驱动。这种情况下我会给他们一个较有争议的建议：不要告诉经理你在重构.这是在搞破坏马？我不这样想。软件开发者都是专业人士。我们的工作就是尽量创造高效软件。经验告诉我.对于快速创造软件，重构可以带来巨大的帮助。 受进度驱动的经理要我竟可能快速完事，至于怎么完成，那就是我的事情了。我认为最快的方式就是重构，所以我就重构.
</p>
<p>
“事先设计”(upfront design)可以帮助我节省回头工的昂贵成本。于是我很快加强这种预先设计风格。许多人把设计看作软件开发的关键环节，而把编程看作只是机械的低级劳动，但是你要知道，软件和真实机械有很大的差别。软件的可塑性很强，而且完全是思想的产品。正如Alistair Cockburn所说的:”有了设计，我们可以思考更快，但是其中充满小漏洞”
</p>
<p>
优秀程序员肯定会少花一些时间来清理自己的代码。这么做是因为，他们知道间接的代码比杂乱无章的代码更容易修改，而且他们知道自己几乎无法已开始就编写出简洁的代码。
</p>
<p>
在对象设计的过程中，“决定把责任放在那里”即使不是最重要的事情，也是最重要的事情之一。我使用对象技术已经十多年了，但是还不能一开始就保证确
</p>
<p>
明天，或者后天，或者下个月，甚至可能明年，灵感总回来的。为了等待进行一项重构的后一半所需要的灵感，我最多曾经等过9个月。你可能会明白自己错在哪里，明白自己对在哪里，总之都能使你想清楚下一步应该如何进行。然后你就可以像最初一样自信地跨出一步。也许你羞愧地想：我太笨了，竟然这么久都没有想到这一步。大可不必，每个人都是这样。
</p>
<p>
这有点像在悬崖峭壁上的小径行走：只要有光，你就可以前进。虽然谨慎却仍然自信，但是一旦太阳下山，你就应该停止前进。夜晚你应该睡觉，相信明天太阳依然升起。(该吃饭时就吃饭,该重构时就重构)
</p>
<p>
两个家伙的车子在山顶附近抛锚了，于是他们走下车，一人走到车的一头，开始推车。经过半个小时但是却毫无成果，车头的那家伙开始说道：“我从来不知道把车子推下山这么难”。另一个家伙答到：“你说推下山是什么意思，难道我们不是想把车子推上山吗？”我猜你一定不想让这个故事在你的团队中重演吧！进行大规模重构之前，有必要为整个开发团队建立共识。(这个笑话感觉很震撼)
</p>
</div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> 虚拟机设计与实现</h3>
<div class="outline-text-3" id="text-1-8">

<p>这种因计算机平台的推陈出新而让我遇到的尴尬局面让我耿耿于怀，我希望能够在一种相对比较稳定的目标平台上面进行软件的开发，好让我设计出来的软件能够有一个更长的生命周期。计算机科学是一个充满着变化的海洋，新技术随时都会涌现，而每涌现一种新技术，就会掀起一连串的惊涛骇浪，我想要得是一个能够让我躲避这种风浪的小岛。经过这么多年的闯荡，我终于发现一个可以让我信赖和依靠的东西：每一种新推出的计算机平台上都有一个ANSI C或者是C++编译器。与其使用那些针对特定硬件平台的开发工具来编写软件，为什么不打自己的程序建立在一种稳定的技术标准之上呢？随手可得的ANSI C来构造一套技术标准并不困难，那我为什么不这么做呢？与以来某种特殊平台来执行应用软件的情况相比，采用虚拟机的解决方案无疑更好。这样我能够简单地以移植虚拟机的办法来缓解因硬件方面的进步而给软件开发带来的压力。
</p>
<p>
在读研究生的时候，我知道了一些能够确保研究生论文得到发表的小招数。例如，即使某位教授发现的东西用很简单的话就能够解释清楚，他也经常会写出一篇很长的论文，里面还会提到很多很深奥的基础，是她的发现看起来要比实际情况复杂得多。这是一种比较普通的社会现象，因为人们往往会有这样一种思维定势：如果某个想法能够用很简单的道理解释清楚，它的重要性或者是独创性就会大打折扣。想要给订阅科技刊物的人们留下深刻印象，就必须把问题描述的很复杂，就必须把问题的解释隐藏在重重迷雾当中。对于像抱住自己的饭碗的教授来说，这无可厚非，但是软件工程是千万不能这样。想要避免项目的失败，就必须坚持简洁的设计理念。
</p>
<p>
更糟糕的是，在1980年代，该公司有位主管认为源代码里面的程序注视会拖延编译时间（其实只是从一天延长到两天而已），于是决定把程序中的注释全部删除掉。到现在，这家公司手里有16，000，000行用K&amp;R C语言编写的源代码，里面一点儿注视都没有。这可能会是很少部分人暗自窃喜–因为他们现在可以垄断有价值的信息了，新招聘来的工程师却不得不面对一条90度的学习曲线。
</p>
<p>
我想告诉大家，软件质量必须从头抓起，为了抢先推出产品而粗糙编写的程序代码等到临出门时再来改进就来不及了，根本无可救药。程序员赶工期而让质检(quality assurance,QA)人员收拾残局的做法无异于饮鸩止渴。记住，慢功出细活。想要编写出无懈可击的高水平软件，就必须在深思熟虑的基础上循序渐进。这条路可能很难走，但是他却是唯一的正确的道路。那些持其他观点的人不时有自己的小算盘，就是想看你的笑话。
</p>
<p>
作为软件开发人员，必须了解一件事情：你参加开发的每个软件项目都可能是“紧急情况”，至少是那些项目经理们都喜欢这么讲。这不过是软件开发行业里的“狼来了”的故事，经理们之所以喜欢这么讲，目的就是为了催促你更快些出程序。销售人员的另一桩“罪行”是在软件的功能方面夸大其词。为了让自己的产品能够从竞争者当中脱颖而出，销售人员经常会在顾客介绍软件功能的时候信口开河。然后他们会跑到你的办公室中宣部这个消息，可六个拟开发这些新功能的时间仅仅只有三天。作为软件开发人员，想要在这种情况下保护自己，可以在项目开始之处把各项需求罗列出来并且让公司销售部门的领导签字认可。这样当某个销售人员跑到你的办公室并试图迫使你就范的时候，就可以把这份由他们头儿签字的文件摔在他脸上，让他滚蛋。
</p></div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-08-10 09:56:18 CST</p>
<p class="creator">Org version 7.8.02 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
<html><body>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F54a700ad7035f6e485eaf2300641e7e9' type='text/javascript'%3E%3C/script%3E"));
</script></body></html>