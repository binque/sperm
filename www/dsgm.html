<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>dsgm</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="dsgm"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-07-31 17:25:10 CST"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">dsgm</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 dsgm</a>
<ul>
<li><a href="#sec-1-1">1.1 Design</a></li>
<li><a href="#sec-1-2">1.2 Implementation</a></li>
<li><a href="#sec-1-3">1.3 Code</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1 创建IMAP对象</a></li>
<li><a href="#sec-1-3-2">1.3.2 检查邮箱内部邮件数目</a></li>
<li><a href="#sec-1-3-3">1.3.3 查询某个时间点以后的mail uid</a></li>
<li><a href="#sec-1-3-4">1.3.4 请求mail的body_header提取subject</a></li>
<li><a href="#sec-1-3-5">1.3.5 请求mail的body提取附件</a></li>
<li><a href="#sec-1-3-6">1.3.6 发送带附件的mail</a></li>
<li><a href="#sec-1-3-7">1.3.7 数据库管理</a></li>
<li><a href="#sec-1-3-8">1.3.8 配置文件</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4 Tutorial</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> dsgm</h2>
<div class="outline-text-2" id="text-1">


<p>
code: <a href="https://github.com/dirtysalt/sperm/tree/master/code/py/dsgm">https://github.com/dirtysalt/sperm/tree/master/code/py/dsgm</a>
</p>
<p>
dsgm(Document Synchronization based on Google Mail)主要是为了解决文档数据同步问题。这里所谓的文档包括
</p><ul>
<li>.doc
</li>
<li>.ppt
</li>
<li>.pdf
</li>
</ul>

<p>通常来说这些文档都是不经常变化的，一旦存储之后很少修改。对于这些之后的版本都可以使用全量进行保存。
之所以考虑使用gmail来进行存储的话，一方面考虑的是免费存储空间，另外一方面考虑的是使用gmail可以与
google docs互连，方便在线打开编辑，以及共享等操作。
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Design</h3>
<div class="outline-text-3" id="text-1-1">

<p>assumption:
</p><ul>
<li>file number : 10k
</li>
<li>本地不考虑多进程启动情况。工作方式非常类似于git pull和git push.这个决定了使用方式。
</li>
<li>本地需要同步的文档全部都放在单独一个文件夹下面，在这个文件夹下面也可以建立层级文件夹而不强制平级放置。
</li>
<li>同步文件夹下面所有文件，而不仅仅只是文档。但是文档更加preferred原因之前说过。
</li>
<li>文件上传之后就很少发生修改。如果频繁修改的文档可以考虑使用github进行备份。
</li>
<li>不考虑文档删除情况。我们始终以本地和邮箱文档的{并集合}作为标准。
</li>
</ul>


<p>
NOTE(dirlt):我们可以稍微限制一下上传文件类型。这样文件上传之后就可以很方便地查看了。
</p><ul>
<li>.doc
</li>
<li>.docx
</li>
<li>.ppt
</li>
<li>.pptx
</li>
<li>.pps
</li>
<li>.pdf
</li>
</ul>

<p>这个类型可以不断地增加对于原有系统不会存在任何问题。
</p>
<p>
dsgm workflow:
</p><ul>
<li>从gmail上面将邮箱里面所有的uid全部拿下，和本地DB进行对比，确认哪些uid可能是本地不存在的。
</li>
<li>从gmail上面检查远端新邮件标题信息，标题信息里面包含文件名称以及对应的md5.更新本地DB.(这个DB保存gmail端的信息).
</li>
<li>扫描本地目录，得到所有的文件名称以及对应的md5.形成集合X
</li>
<li>如果集合X中存在元素而DB中不存在的话，那么就进行push.如果集合X中不存在元素而DB存在的话，那么就pull. 
</li>
</ul>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Implementation</h3>
<div class="outline-text-3" id="text-1-2">

<p>以boost/libs为例，扫描一遍大约在80ms.然后如果每个文件都做md5的话，扫描一遍大约在600ms以内。但是每个文件都是.cpp或者是.h.大约在1K级别，
而平均文档的话都在1M左右，所以扫描一遍并且做md5的话大约会在10s内。如果可以通过考虑首先判断时间戳，然后判断md5的方式来减少开销代价。
</p>


<pre class="example">dirlt@dirlt-virtual-machine:~/utils/boost_1_49_0/libs$ time find . -type f | wc
  21322   21322 1007902

real    0m0.080s
user    0m0.040s
sys     0m0.040s

dirlt@dirlt-virtual-machine:~/utils/boost_1_49_0/libs$ time find . -type f | xargs md5sum &gt;/dev/null     

real    0m0.657s
user    0m0.460s
sys     0m0.232s
</pre>

<p>
使用检测新增文件的话那么就需要启动一个daemon程序，这样会加大程序复杂度。
</p>
<p>
假设同步文件为X/Y/Z.doc的话：
</p><ul>
<li>那么邮件标题是[dsgm]Z.doc@(md5 X/Y/Z.doc)$X@Y.这样文件的元信息都可以通过分析邮箱标题得到，同时可以通过邮箱引擎检索到。
</li>
<li>邮件正文没有任何内容，但是后面可以考虑做一些摘要信息。TODO(dirlt):how to extract digest from doc???
</li>
<li>邮件附件保存的是所需要同步的文件，名称为Z.doc
</li>
</ul>


<p>
如何管理冲突：
</p><ul>
<li>出现的情况就是AB两处各有D的一个版本，然后A先上传，之后B在进行pull的时候，文件同名。
</li>
<li>对于这种情况，B在pull的时候，会判断本地是否有同名文件存在
</li>
<li>如果存在文件同名的话，那么将新下载的文件修改成为Z-C{md5}.doc这样的格式。NOTE(dirlt):使用时间标记的话可以让我们了解冲突。
</li>
<li>然后再push的时候，需要忽略这样的文件，因为这种格式的文件并不是本地用户自己产生的。
</li>
</ul>

<p>NOTE(dirlt):如果用户想进行merge的话，可以新创建一个文件，叫做Z-M{version-number}.doc(只是推荐这么叫).因为我们并不支持用户删除文件。
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Code</h3>
<div class="outline-text-3" id="text-1-3">

<p>首先看是否有现成的gmail libary. in Java or Python. 
</p>
<p>
gmail4j <a href="http://code.google.com/p/gmail4j/">http://code.google.com/p/gmail4j/</a> 似乎已经停止更新了，而且API docs也找不到了。
google search 到这个 API <a href="http://www.jarvana.com/jarvana/view/com/googlecode/gmail4j/gmail4j/0.4/gmail4j-0.4-javadoc.jar!/index.html">http://www.jarvana.com/jarvana/view/com/googlecode/gmail4j/gmail4j/0.4/gmail4j-0.4-javadoc.jar!/index.html</a>
粗略地浏览了一下，发现很多功能还是不具备的，只能够下载Unread Message.同时Message里面没有办法嵌入附件。这点非常讨厌。
</p>


<pre class="src src-Java">// GmailClient client=new ImapGmailClient();
// GmailConnection conn=new ImapGmailConnection();
// conn.setLoginCredentials(gmailUser,gmailPass.toCharArray());
// client.setConnection(conn);

GmailClient client = new RssGmailClient();
GmailConnection conn= new HttpGmailConnection(gmailUser, gmailPass.toCharArray());
client.setConnection(conn);
for (GmailMessage message : client.getUnreadMessages()) {
  System.out.println(message.getFrom() + <span style="color: #ffff00;">": "</span> + message.getSubject());
}
</pre>

<p>
另外使用ImapGmailClient/ImapGmailConnection似乎没有办法使用(可能gmail接口变化了).只能够使用Rss这个接口。放弃!!!
</p>
<p>
TODO(dirlt):使用原生SMTP以及IMAP接口 in python.
</p>
<p>
libgmail <a href="http://libgmail.sourceforge.net/">http://libgmail.sourceforge.net/</a> 似乎已经停止更新很久了。看了一下代码应该是使用gmail提供的API完成的。
简单使用了一下发现还是有很多问题的。虽然我修改了一下代码，但是依然不能够工作。应该是gmail API发生了变化。
</p>


<pre class="example">dirlt@dirlt-virtual-machine:~$ ./test.py 
Traceback (most recent call last):
  File "./test.py", line 12, in &lt;module&gt;
    ga.login()
  File "/usr/local/lib/python2.7/dist-packages/libgmail.py", line 305, in login
    pageData = self._retrievePage(req)
  File "/usr/local/lib/python2.7/dist-packages/libgmail.py", line 340, in _retrievePage
    req = ClientCookie.Request(urlOrRequest)
  File "/usr/local/lib/python2.7/dist-packages/mechanize-0.2.5-py2.7.egg/mechanize/_request.py", line 31, in __init__
    if not _rfc3986.is_clean_uri(url):
  File "/usr/local/lib/python2.7/dist-packages/mechanize-0.2.5-py2.7.egg/mechanize/_rfc3986.py", line 62, in is_clean_uri
    return not bool(BAD_URI_CHARS_RE.search(uri))
</pre>


<p>
使用Python imaplib吧!!!
</p><ul>
<li><a href="http://www.doughellmann.com/PyMOTW/imaplib/">http://www.doughellmann.com/PyMOTW/imaplib/</a>
</li>
<li><a href="http://stackoverflow.com/questions/2792623/reading-and-parsing-email-from-gmail-using-c-c-or-python">http://stackoverflow.com/questions/2792623/reading-and-parsing-email-from-gmail-using-c-c-or-python</a>
</li>
<li><a href="http://www.cnblogs.com/lonelycatcher/archive/2012/02/09/2343480.html">http://www.cnblogs.com/lonelycatcher/archive/2012/02/09/2343480.html</a>
</li>
<li>
</li>
</ul>


<p>
NOTE(dirlt):似乎我们没有明确我们需要的操作。大致上我们需要的操作包括：
</p><ul>
<li>下载某个mailbox所有标题。
</li>
<li>下载某个邮件以及对应的附件。
</li>
<li>发送带附件的邮件。
</li>
</ul>



</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 创建IMAP对象</h4>
<div class="outline-text-4" id="text-1-3-1">




<pre class="src src-Python">def make_gmail_imap(username,password,mailbox):
    import imaplib
    m=imaplib.IMAP4_SSL('imap.gmail.com',993)
    m.login(username,password)
    if(mailbox):
        m.create(mailbox) # to assure it exists
        m.select(mailbox)
    return m
</pre>


</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> 检查邮箱内部邮件数目</h4>
<div class="outline-text-4" id="text-1-3-2">




<pre class="src src-Python">(type,data)=m.select(mailbox)
if(type=='OK'):
    return int(data)
</pre>


</div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> 查询某个时间点以后的mail uid</h4>
<div class="outline-text-4" id="text-1-3-3">

<p>NOTE(dirlt):使用这个函数可以做到不需要同步很早之前的数据了。
</p>
<p>
NOTE(dirlt):不过这个似乎现在没有必要用上了。因为uid非常小所以我们每次fetch全量即可。
</p>


<pre class="src src-Python">def make_imapdate(reserve_day=10):
    import time
    now=time.time()
    now-=(reserve_day * 3600 * 24)
    return time.strftime('%d-%b-%Y',time.localtime(now))
print make_imapdate()

def request_uids_after_imapdate(imap, imapdate):
    type, data=imap.uid('SEARCH','(SENTSINCE '+imapdate+')')
    return data[0].split()
</pre>



</div>

</div>

<div id="outline-container-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> 请求mail的body_header提取subject</h4>
<div class="outline-text-4" id="text-1-3-4">

<p>NOTE(dirlt):现在代码里面不是这样实现的，不过基本结构类似。
</p>



<pre class="src src-Python">def request_body_header(imap, uid):
    type, data=imap.uid('FETCH',uid, '(RFC822.HEADER)')
    if(type != 'OK'):
        return None
    return data

def extract_subject_from_body_header(body_header):
    headers=body_header[0][1].split('\r\n')
    #Subject: Fwd: =?GB2312?B?1cLR19C0uPjP/rartcTQxQ==?=
    subject=filter(lambda x:x.startswith('Subject: '),headers)[0][len('Subject: '):]
    return subject

def parse_subject(subject):
    import email.header
    parts=email.header.decode_header(subject)
    return map(lambda x:x[0].decode(x[1] or 'utf8'),parts)

print parse_subject('Fwd: =?GB2312?B?1cLR19C0uPjP/rartcTQxQ==?=')
</pre>


</div>

</div>

<div id="outline-container-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> 请求mail的body提取附件</h4>
<div class="outline-text-4" id="text-1-3-5">

<p>NOTE(dirlt):只是提取一个附件.
</p>


<pre class="src src-Python">def request_body(imap, uid):
    type, data=imap.uid('FETCH', uid, '(RFC822)')
    if(type != 'OK'):
        return None
    return data

def extract_attachment_from_body(body):
    import email
    msg=email.message_from_string(body[0][1])
    assert(msg.is_multipart()) # usually it is!!!
    for part in msg.walk():
        if(part.get_filename()): # find attachment.
            filename=part.get_filename()
            payload=part.get_payload()
            # base64 decode
            import base64
            content=base64.b64decode(payload)
            # I think just one attachment.
            return content
    return None
</pre>


</div>

</div>

<div id="outline-container-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> 发送带附件的mail</h4>
<div class="outline-text-4" id="text-1-3-6">

<p>NOTE(dirlt):这里最好能够只能地判断MIME类型就好了。
</p>



<pre class="src src-Python">def make_mail_with_attachment(f, to, subject, text, file):
    import os
    from email.mime.multipart import MIMEMultipart
    from email.mime.base import MIMEBase
    from email.mime.text import MIMEText    
    from email import encoders

    msg = MIMEMultipart()
    msg['From'] = f
    msg['To'] = to
    msg['Subject'] = subject 
    if(text):
        msg.attach(MIMEText(text))
    if(file):        
        #part = MIMEBase('application', 'octet-stream') #'octet-stream': binary data 
        part = MIMEBase('text','plain')
        part.set_payload(open(file, 'rb').read())
        encoders.encode_base64(part) 
        part.add_header('Content-Disposition', 'attachment; filename=<span style="color: #ffff00;">"%s"</span>' % os.path.basename(file))
        msg.attach(part)
    return msg

def send_mail(imap, mailbox, mail):
    import time
    imap.append(mailbox, '' , time.localtime(time.time()), msg.as_string())
</pre>


</div>

</div>

<div id="outline-container-1-3-7" class="outline-4">
<h4 id="sec-1-3-7"><span class="section-number-4">1.3.7</span> 数据库管理</h4>
<div class="outline-text-4" id="text-1-3-7">

<p>使用gdbm来进行数据库管理，因为我们只需要简单的key-value即可。对于同步的文件可以使用上传邮件标题来作为key,value=mail uid.
如果邮件删除的话，那么mail uid=0来单独标记。
</p>
<p>
NOTE(dirlt):自己实现了一个简单的redo-log方式的db.更加可读。
</p>
</div>

</div>

<div id="outline-container-1-3-8" class="outline-4">
<h4 id="sec-1-3-8"><span class="section-number-4">1.3.8</span> 配置文件</h4>
<div class="outline-text-4" id="text-1-3-8">

<p>配置文件使用简单的key=value格式完成。配置项在程序目录下面称为dsgm.conf文件。需要用户提供
</p><ul>
<li>gmail.user
</li>
<li>gmail.password
</li>
<li>document.directory
</li>
</ul>

<p>NOTE(dirlt):用户最好注册一个单独的gmail,这个gmail不要使用pop来收邮件，不然会重复下载邮件。
</p>

</div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Tutorial</h3>
<div class="outline-text-3" id="text-1-4">

<ul>
<li>我们希望同步本地目录/home/xyz/dsgm-sync
</li>
<li>申请一个gmail邮箱。假设mail和password为 xyz@gmail.com xyz
</li>
<li>在dsgm的目录下面新建文件dsgm.conf，内容为
</li>
</ul>




<pre class="example">gmail.username = xyz@gmail.com
gmail.password = xyz
document.directory= /home/xyz/dsgm-sync
</pre>

<ul>
<li>然后使用dsgm
</li>
</ul>


<p>
dsgm命令行参数
</p><ul>
<li>dsgm help # 帮助信息     
</li>
<li>dsgm pull # 
</li>
<li>dsgm push # 
</li>
<li>dsgm # dsgm pull + dsgm push
</li>
</ul>


</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-07-31 17:25:10 CST</p>
<p class="creator">Org version 7.8.02 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
