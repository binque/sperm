<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>algorithm</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="algorithm"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-09-03 17:42:43 CST"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">algorithm</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 algorithm</a>
<ul>
<li><a href="#sec-1-1">1.1 glibc strlen实现分析</a></li>
<li><a href="#sec-1-2">1.2 一致性hash(Consistent hashing)</a></li>
<li><a href="#sec-1-3">1.3 树最长距离</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> algorithm</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> glibc strlen实现分析</h3>
<div class="outline-text-3" id="text-1-1">

<p>参考链接 <a href="http://www.kuqin.com/language/20071113/2308.html">http://www.kuqin.com/language/20071113/2308.html</a>. 这里和链接有点不太一样的就是，这个版本glibc实现考虑了非ASCII字符。
</p>



<pre class="src src-C++">size_t strlen(str)
const char *str;
{
  const char *char_ptr;
  const unsigned long int *longword_ptr;
  unsigned long int longword, himagic, lomagic;

  // &#39318;&#20808;&#26159;&#38656;&#35201;&#23545;&#40784;&#21040;unsigned long int&#36825;&#20010;&#38271;&#24230;.
  // &#20043;&#21518;&#23601;&#26159;&#27599;&#20010;unsigned long int&#26469;&#36827;&#34892;&#21028;&#26029;.
  // &#36825;&#26679;&#21487;&#20197;&#21152;&#24555;&#36895;&#24230;

  /* Handle the first few characters by reading one character at a time.
   * Do this until CHAR_PTR is aligned on a longword boundary.  */
  for (char_ptr = str; ((unsigned long int) char_ptr
                        &amp; (sizeof(longword) - 1)) != 0; ++char_ptr)
    if (*char_ptr == '\0')
      return char_ptr - str;

  /* All these elucidatory comments refer to 4-byte longwords,
   * but the theory applies equally well to 8-byte longwords.  */

  longword_ptr = (unsigned long int *) char_ptr;

  // &#20026;&#20102;&#31616;&#21270;&#22788;&#29702;&#30340;&#35805;&#65292;&#25105;&#20204;&#21487;&#20197;&#35748;&#20026;sizeof(longword)==8&#65292;&#36825;&#26679;
  // himagic = 0x8080808080808080L
  // lomagic = 0x0101010101010101L

  /* Bits 31, 24, 16, and 8 of this number are zero.  Call these bits
   * the <span style="color: #ffff00;">"holes."</span>  Note that there is a hole just to the left of
   * each byte, with an extra at the end:
   *
   * bits:  01111110 11111110 11111110 11111111
   * bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD
   *
   * The 1-bits make sure that carries propagate to the next 0-bit.
   * The 0-bits provide holes for carries to fall into.  */
  himagic = 0x80808080L;
  lomagic = 0x01010101L;
  if (sizeof(longword) &gt; 4) {
    /* 64-bit version of the magic.  */
    /* Do the shift in two steps to avoid a warning if long has 32 bits.  */
    himagic = ((himagic &lt;&lt; 16) &lt;&lt; 16) | himagic;
    lomagic = ((lomagic &lt;&lt; 16) &lt;&lt; 16) | lomagic;
  }
  if (sizeof(longword) &gt; 8)
    abort();

  /* Instead of the traditional loop which tests each character,
   * we will test a longword at a time.  The tricky part is testing
   * if *any of the four* bytes in the longword in question are zero.  */
  for (;;) {
    longword = *longword_ptr++;

    // &#36825;&#37324;&#21407;&#29702;&#38750;&#24120;&#31616;&#21333;,&#20551;&#35774;&#22312;unsigned long int&#37324;&#38754;&#23384;&#22312;&#19968;&#20010;0&#30340;&#35805;
    // &#37027;&#20040;0-lomagic&#30340;&#35805;&#20250;&#36896;&#25104;&#39640;&#20301;&#20026;1.&#22914;&#26524;!=0&#30340;&#35805;&#37027;&#20040;&#33267;&#23569;&gt;=1&#23601;&#19981;&#20250;&#36896;&#25104;&#23545;&#24212;&#23383;&#33410;&#39640;&#23383;&#33410;&#20026;1&#20102;.
    // &#24403;&#28982;&#36825;&#37324;&#36824;&#26377;&#19968;&#31181;&#24773;&#20917;&#23601;&#26159;&#36825;&#20010;&#19981;&#26159;&#19968;&#20010;ASCII&#23383;&#31526;.
    // &#20351;&#29992;&amp; ~longword&#26469;&#21028;&#26029;&#30340;&#35805;,&#22914;&#26524;&#39640;&#20301;&#23601;&#20026;1&#30340;&#35805;&#37027;&#20040;&#23601;&#20250;&#32622;&#20026;0,&#36825;&#26679;&#23601;&#25490;&#38500;&#20102;&#38750;ASCII&#24773;&#20917;.
    // &#28982;&#21518;&amp; himagic&#30340;&#35805;,&#26469;&#21028;&#26029;&#26159;&#21542;&#26377;&#39640;&#20301;&#20026;1.&#22914;&#26524;&#26377;&#30340;&#35805;&#35828;&#26126;&#36825;&#20960;&#20010;&#23383;&#33410;&#37324;&#38754;&#23384;&#22312;0.
    // &#22914;&#26524;&#23384;&#22312;0&#30340;&#35805;&#37027;&#20040;&#23601;&#21482;&#26159;&#38024;&#23545;&#36825;8&#20010;&#23383;&#33410;&#36827;&#34892;&#26522;&#20030;

    if (((longword - lomagic) &amp; ~longword &amp; himagic) != 0) {
      /* Which of the bytes was the zero?  If none of them were, it was
       * a misfire; continue the search.  */

      const char *cp = (const char *) (longword_ptr - 1);

      if (cp[0] == 0)
        return cp - str;
      if (cp[1] == 0)
        return cp - str + 1;
      if (cp[2] == 0)
        return cp - str + 2;
      if (cp[3] == 0)
        return cp - str + 3;
      if (sizeof(longword) &gt; 4) {
        if (cp[4] == 0)
          return cp - str + 4;
        if (cp[5] == 0)
          return cp - str + 5;
        if (cp[6] == 0)
          return cp - str + 6;
        if (cp[7] == 0)
          return cp - str + 7;
      }
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 一致性hash(Consistent hashing)</h3>
<div class="outline-text-3" id="text-1-2">

<ul>
<li><a href="http://en.wikipedia.org/wiki/Consistent_hash">http://en.wikipedia.org/wiki/Consistent_hash</a>
</li>
<li><a href="http://www.tomkleinpeter.com/2008/03/17/programmers-toolbox-part-3-consistent-hashing/">http://www.tomkleinpeter.com/2008/03/17/programmers-toolbox-part-3-consistent-hashing/</a>
</li>
<li><a href="http://cn.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients">http://cn.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients</a>
</li>
<li><a href="http://www.martinbroadhurst.com/Consistent-Hash-Ring.html">http://www.martinbroadhurst.com/Consistent-Hash-Ring.html</a>
</li>
<li><a href="http://www.lexemetech.com/2007/11/consistent-hashing.html">http://www.lexemetech.com/2007/11/consistent-hashing.html</a>
</li>
</ul>

<p>The basic idea behind the consistent hashing algorithm is to hash both objects and caches using the same hash function.The reason to do this is to map the cache to an interval, which will contain a number of object hashes. If the cache is removed then its interval is taken over by a cache with an adjacent interval. All the other caches remain unchanged.
</p>
<p>
一致性hash基本思想就是将所有对象都使用同样的hash函数进行hash(包括要被分布的对象，以及分布到的位置）。如果某个分布位置被移除的话，那么原本在这个位置上的对象就会分布在临近的分布位置上，而其他的对象却不用移动自己的位置。如果分布位置之间interval间隔过大的话那么可以制作virtual node来使得interval映射足够小，而这些virtual node映射到同一个node节点上面。实际上上述文章中也进行实验证明interval小的话那么standard deviations也变小了，每个node均摊的object基本均匀了：）。
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 树最长距离</h3>
<div class="outline-text-3" id="text-1-3">

<p>树的最长距离定义为任意两个节点之间距离的最大值。咋一看这个问题，似乎就是根节点左子树高度和右子树高度之和，但是实际上可能对于子树里面可能会存在更长的距离。对于最长距离的话应该仅存在于这两者之间。
</p>



<pre class="src src-Python">#!/usr/bin/env python
#coding:utf-8
#Copyright (C) dirlt

def tree_dist(root):
    if(not root):
        return (0,-1,-1)
    (a,b,c)=tree_dist(root.left)
    (d,e,f)=tree_dist(root.right)
    ml=max(b,c)+1
    mr=max(e,f)+1
    return (max(a,d,ml+mr),ml,mr)

def TreeDistance(root):
    return tree_dist(root)[0]
</pre>


<p>
对于返回元组来说的话(a,b,c)，a表示树的最长距离，b表示左子树的高度，c表示右子树的高度。
</p>
</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-09-03 17:42:43 CST</p>
<p class="creator">Org version 7.8.02 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
<html><body>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F54a700ad7035f6e485eaf2300641e7e9' type='text/javascript'%3E%3C/script%3E"));
</script></body></html>