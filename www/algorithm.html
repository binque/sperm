<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>algorithm</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="algorithm"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-10-26 14:21:27 CST"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">algorithm</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 algorithm</a>
<ul>
<li><a href="#sec-1-1">1.1 glibc strlen实现分析</a></li>
<li><a href="#sec-1-2">1.2 一致性hash(Consistent hashing)</a></li>
<li><a href="#sec-1-3">1.3 树最长距离</a></li>
<li><a href="#sec-1-4">1.4 rsync的核心算法</a></li>
<li><a href="#sec-1-5">1.5 开门抽奖问题</a></li>
<li><a href="#sec-1-6">1.6 simhash算法原理和文档近似判断</a></li>
<li><a href="#sec-1-7">1.7 等概率选取未知长度的链表中的元素</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> algorithm</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> glibc strlen实现分析</h3>
<div class="outline-text-3" id="text-1-1">

<p>参考链接 <a href="http://www.kuqin.com/language/20071113/2308.html">http://www.kuqin.com/language/20071113/2308.html</a>. 这里和链接有点不太一样的就是，这个版本glibc实现考虑了非ASCII字符。
</p>



<pre class="src src-C++">size_t strlen(str)
const char *str;
{
  const char *char_ptr;
  const unsigned long int *longword_ptr;
  unsigned long int longword, himagic, lomagic;

  // &#39318;&#20808;&#26159;&#38656;&#35201;&#23545;&#40784;&#21040;unsigned long int&#36825;&#20010;&#38271;&#24230;.
  // &#20043;&#21518;&#23601;&#26159;&#27599;&#20010;unsigned long int&#26469;&#36827;&#34892;&#21028;&#26029;.
  // &#36825;&#26679;&#21487;&#20197;&#21152;&#24555;&#36895;&#24230;

  /* Handle the first few characters by reading one character at a time.
   * Do this until CHAR_PTR is aligned on a longword boundary.  */
  for (char_ptr = str; ((unsigned long int) char_ptr
                        &amp; (sizeof(longword) - 1)) != 0; ++char_ptr)
    if (*char_ptr == '\0')
      return char_ptr - str;

  /* All these elucidatory comments refer to 4-byte longwords,
   * but the theory applies equally well to 8-byte longwords.  */

  longword_ptr = (unsigned long int *) char_ptr;

  // &#20026;&#20102;&#31616;&#21270;&#22788;&#29702;&#30340;&#35805;&#65292;&#25105;&#20204;&#21487;&#20197;&#35748;&#20026;sizeof(longword)==8&#65292;&#36825;&#26679;
  // himagic = 0x8080808080808080L
  // lomagic = 0x0101010101010101L

  /* Bits 31, 24, 16, and 8 of this number are zero.  Call these bits
   * the <span style="color: #00ffff; font-style: italic;">"holes."</span>  Note that there is a hole just to the left of
   * each byte, with an extra at the end:
   *
   * bits:  01111110 11111110 11111110 11111111
   * bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD
   *
   * The 1-bits make sure that carries propagate to the next 0-bit.
   * The 0-bits provide holes for carries to fall into.  */
  himagic = 0x80808080L;
  lomagic = 0x01010101L;
  if (sizeof(longword) &gt; 4) {
    /* 64-bit version of the magic.  */
    /* Do the shift in two steps to avoid a warning if long has 32 bits.  */
    himagic = ((himagic &lt;&lt; 16) &lt;&lt; 16) | himagic;
    lomagic = ((lomagic &lt;&lt; 16) &lt;&lt; 16) | lomagic;
  }
  if (sizeof(longword) &gt; 8)
    abort();

  /* Instead of the traditional loop which tests each character,
   * we will test a longword at a time.  The tricky part is testing
   * if *any of the four* bytes in the longword in question are zero.  */
  for (;;) {
    longword = *longword_ptr++;

    // &#36825;&#37324;&#21407;&#29702;&#38750;&#24120;&#31616;&#21333;,&#20551;&#35774;&#22312;unsigned long int&#37324;&#38754;&#23384;&#22312;&#19968;&#20010;0&#30340;&#35805;
    // &#37027;&#20040;0-lomagic&#30340;&#35805;&#20250;&#36896;&#25104;&#39640;&#20301;&#20026;1.&#22914;&#26524;!=0&#30340;&#35805;&#37027;&#20040;&#33267;&#23569;&gt;=1&#23601;&#19981;&#20250;&#36896;&#25104;&#23545;&#24212;&#23383;&#33410;&#39640;&#23383;&#33410;&#20026;1&#20102;.
    // &#24403;&#28982;&#36825;&#37324;&#36824;&#26377;&#19968;&#31181;&#24773;&#20917;&#23601;&#26159;&#36825;&#20010;&#19981;&#26159;&#19968;&#20010;ASCII&#23383;&#31526;.
    // &#20351;&#29992;&amp; ~longword&#26469;&#21028;&#26029;&#30340;&#35805;,&#22914;&#26524;&#39640;&#20301;&#23601;&#20026;1&#30340;&#35805;&#37027;&#20040;&#23601;&#20250;&#32622;&#20026;0,&#36825;&#26679;&#23601;&#25490;&#38500;&#20102;&#38750;ASCII&#24773;&#20917;.
    // &#28982;&#21518;&amp; himagic&#30340;&#35805;,&#26469;&#21028;&#26029;&#26159;&#21542;&#26377;&#39640;&#20301;&#20026;1.&#22914;&#26524;&#26377;&#30340;&#35805;&#35828;&#26126;&#36825;&#20960;&#20010;&#23383;&#33410;&#37324;&#38754;&#23384;&#22312;0.
    // &#22914;&#26524;&#23384;&#22312;0&#30340;&#35805;&#37027;&#20040;&#23601;&#21482;&#26159;&#38024;&#23545;&#36825;8&#20010;&#23383;&#33410;&#36827;&#34892;&#26522;&#20030;

    if (((longword - lomagic) &amp; ~longword &amp; himagic) != 0) {
      /* Which of the bytes was the zero?  If none of them were, it was
       * a misfire; continue the search.  */

      const char *cp = (const char *) (longword_ptr - 1);

      if (cp[0] == 0)
        return cp - str;
      if (cp[1] == 0)
        return cp - str + 1;
      if (cp[2] == 0)
        return cp - str + 2;
      if (cp[3] == 0)
        return cp - str + 3;
      if (sizeof(longword) &gt; 4) {
        if (cp[4] == 0)
          return cp - str + 4;
        if (cp[5] == 0)
          return cp - str + 5;
        if (cp[6] == 0)
          return cp - str + 6;
        if (cp[7] == 0)
          return cp - str + 7;
      }
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 一致性hash(Consistent hashing)</h3>
<div class="outline-text-3" id="text-1-2">

<ul>
<li><a href="http://en.wikipedia.org/wiki/Consistent_hash">http://en.wikipedia.org/wiki/Consistent_hash</a>
</li>
<li><a href="http://www.tomkleinpeter.com/2008/03/17/programmers-toolbox-part-3-consistent-hashing/">http://www.tomkleinpeter.com/2008/03/17/programmers-toolbox-part-3-consistent-hashing/</a>
</li>
<li><a href="http://cn.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients">http://cn.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients</a>
</li>
<li><a href="http://www.martinbroadhurst.com/Consistent-Hash-Ring.html">http://www.martinbroadhurst.com/Consistent-Hash-Ring.html</a>
</li>
<li><a href="http://www.lexemetech.com/2007/11/consistent-hashing.html">http://www.lexemetech.com/2007/11/consistent-hashing.html</a>
</li>
</ul>

<p>The basic idea behind the consistent hashing algorithm is to hash both objects and caches using the same hash function.The reason to do this is to map the cache to an interval, which will contain a number of object hashes. If the cache is removed then its interval is taken over by a cache with an adjacent interval. All the other caches remain unchanged.
</p>
<p>
一致性hash基本思想就是将所有对象都使用同样的hash函数进行hash(包括要被分布的对象，以及分布到的位置）。如果某个分布位置被移除的话，那么原本在这个位置上的对象就会分布在临近的分布位置上，而其他的对象却不用移动自己的位置。如果分布位置之间interval间隔过大的话那么可以制作virtual node来使得interval映射足够小，而这些virtual node映射到同一个node节点上面。实际上上述文章中也进行实验证明interval小的话那么standard deviations也变小了，每个node均摊的object基本均匀了：）。
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 树最长距离</h3>
<div class="outline-text-3" id="text-1-3">

<p>树的最长距离定义为任意两个节点之间距离的最大值。咋一看这个问题，似乎就是根节点左子树高度和右子树高度之和，但是实际上可能对于子树里面可能会存在更长的距离。对于最长距离的话应该仅存在于这两者之间。
</p>



<pre class="src src-Python">#!/usr/bin/env python
#coding:utf-8
#Copyright (C) dirlt

def tree_dist(root):
    if(not root):
        return (0,-1,-1)
    (a,b,c)=tree_dist(root.left)
    (d,e,f)=tree_dist(root.right)
    ml=max(b,c)+1
    mr=max(e,f)+1
    return (max(a,d,ml+mr),ml,mr)

def TreeDistance(root):
    return tree_dist(root)[0]
</pre>


<p>
对于返回元组来说的话(a,b,c)，a表示树的最长距离，b表示左子树的高度，c表示右子树的高度。
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> rsync的核心算法</h3>
<div class="outline-text-3" id="text-1-4">

<ul>
<li><a href="http://coolshell.cn/articles/7425.html">http://coolshell.cn/articles/7425.html</a>
</li>
</ul>


<p>
首先针对dst文件按照block分别求得checksum和md5.其中checksum用来进行弱校验，md5用来进行强校验。所谓弱校验就是如果checksum不等的话那么文件内容必然不相同，强校验就是如果md5相同的话那么文件内容必然相同。但是checksum还有一个好处，就是可以根据[k,k+n)的checksum,很快地计算出[k+1,k+n+1)的checksum.（非常类似于滑动窗口的工作方式）这点对于在src文件中查找相同块非常重要。将每个块的(checksum,md5)传输到源端。
</p>
<p>
源端得到每个块的(checksum,md5)之后，根据checksum作为hashcode插入到hashtable中去。这样源端就了解了目的端现在所有块的情况。然后针对src文件做下面操作：
</p><ol>
<li>k=0
</li>
<li>读取[k,k+512)字节得到checksum. 注意这个checksum可以很快地计算出来。
</li>
<li>如果这个checksum存在于hashtable中，那么说明这个块可能目的端存在，goto 3. 否则说明肯定不存在目的端，goto 5.
</li>
<li>比较md5是否相同，如果相同的话那么认为block相同，否则不同。
</li>
<li>如果这个checksum不存在于hashtable的话，那么说明肯定不存在目的端，goto 5.
</li>
<li>如果全部处理完毕的话那么退出，否则k+=1.
</li>
</ol>

<p>这里需要注意就是checksum可以很快地类似于滑动窗口的工作方式计算出来.
</p>
<p>
源端完成了上面这些操作之后，就可以知道那些块目的端是存在的（以及存在于什么地方），自己有那些块是目的端没有的，然后通过传输增量并且文件拼接来达到数据同步的目的。
</p>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 开门抽奖问题</h3>
<div class="outline-text-3" id="text-1-5">

<p>原题是有三扇门，一扇门后面是一辆汽车，后面两扇门没有东西。主持人首先让你选择一扇门，之后主持人打开一扇后面没有任何东西的门，然后主持人问你是否需要更换你的选择？扩展一下这个问题，如果扩展到N(N&gt;=3)扇门的话，那么之前和之后中奖概率分别是多少？
</p>
<p>
第一步是随机选择那么概率是1/N.但是第二步概率可以这样考虑：
</p><ol>
<li>我当前选择中奖几率是1/N,那么在其他doors后面的几率是N-1/N.
</li>
<li>主持人打开门之后，如果我坚持当前选择的话，中奖几率是没有变化的。剩余的doors后面几率依然是N-1/N.
</li>
<li>而现在剩余的doors只有N-2扇。如果挑选那些剩余doors的话，那么几率是(N-1)/(N*(N-2)).这个几率比1/N要好.
</li>
</ol>

<p>这里如果我们不是换成剩余的doors而是重新选择的话，那么几率依然是(N-1)/(N*(N-1)=1/N.和原来几率是一样的没有变化。
</p>
<p>
思考的关键在于，主持人这个行为对你当前选择的概率是没有任何影响的。因为无论如何主持人都可以打开一扇空门出来。
</p>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> simhash算法原理和文档近似判断</h3>
<div class="outline-text-3" id="text-1-6">

<ul>
<li><a href="http://blog.csdn.net/lgnlgn/article/details/6008498">http://blog.csdn.net/lgnlgn/article/details/6008498</a>
</li>
</ul>


<p>
simhash算法针对文档分析得到文档特征的一个向量表示，然后使用这个向量之间的差距就可以作为文档之间的差别大小，可以用来做文档近似判断。
</p>
<p>
simhash算法原理非常简单：
</p><ol>
<li>创建f-bit的V向量初始化为0
</li>
<li>首先针对文档提取一系列特征C{i}（比如可以抽取比较重要的特征词出现次数等），对于每个特征给定一个权重W{i}
</li>
<li>针对每个特征C{i}求出一个f-bit的hash值，遍历hash值每个bit.如果bit=1的话，那么V{i}+=W{i},否则V{i}-=W{i}
</li>
<li>如果V{i}&gt;0那么V{i}=1,否则V{i}=0.这个V{i}就作为这个文档的simhash值
</li>
</ol>


<p>
可以看到如果simhash之间的bit相差小的话，那么文档之间的相似度就更高，这里没有证明但是可以比较感性地感觉到。两个simhash之间的bit差异个数叫做海明距离。直接比较两个simhash海明距离非常简单，
</p>
<p>
但是现实中有另外一种情况是，我们已经有一组很大的文档集合S以及对应的simhash值，现在我们有一个新来的文档d以及simhash值，我们需要判断在S中是否有和d海明距离小于k的文档。
</p>
<p>
假设S是排好序的个数是N，我们simhash f=64.如果k非常小比如{1,2,3}的话，那么可以枚举和d simhash相差k的所有simhash值，然后再S里面进行检索，时间复杂度在C(64,k)*lgN.但是如果k比较大比如&gt;=10的话，那么我们可以先对S进行分段搜索：
</p><ol>
<li>我们对S进行分段，每次取出2^m个元素，我们确保2^m个元素高位有m’相同。因为S排好序所以通常m'很高。
</li>
<li>我们首先对于m'个位和d simhash高位判断有多少位存在差异，假设x存在差异.这样我们可以在2^m元素判断m-x差异的元素。
</li>
<li>总体思想来说的话就是希望可以缩小搜索集。似乎在算法复杂度上面没有啥改进，可以在实现上改进。
</li>
</ol>

<p>不过话说回来，文档近似判断应该k很小在{1,2}左右。C(64,k)={64,2016}应该并不算太大的值吧。
</p>
</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> 等概率选取未知长度的链表中的元素</h3>
<div class="outline-text-3" id="text-1-7">

<p>要求是只能够遍历这个链表一次。下面是代码， <b>注意这里的wanted会不断地被更新</b> 
</p>


<pre class="src src-C++">int nmatch = 0;
for ( p=list; p!=NULL; p=p-&gt;next ){
    if ( rand() % ++nmatch == 0 ){
        wanted = p;
    }
} 
</pre>


<p>
这个问题可以如此考虑，假设长度为n，那么最后一个元素被选出（选中）的概率为1/n，然后我们考虑倒数第二个元素选出的概率
</p><ul>
<li>倒数第二个元素必须被 <b>选中</b> ，概率为1/(n-1)
</li>
<li>并且确保倒数第一个元素没有被 <b>选中</b> 。因为最后一个选中概率为1/n，所以最后一个元素不被选中概率为(n-1)/n
</li>
</ul>

<p>因此倒数第二个元素被选出的概率为 1/(n-1) * (n-1)/n = 1/n. 同理计算对于每一个元素的概率都是 1/n.
</p>
</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-10-26 14:21:27 CST</p>
<p class="creator">Org version 7.8.11 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
<html><body>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F54a700ad7035f6e485eaf2300641e7e9' type='text/javascript'%3E%3C/script%3E"));
</script></body></html>