* megastore
#+OPTIONS: H:5
   - link: http://research.google.com/pubs/pub36971.html
   - title: Megastore: Providing Scalable, Highly Available Storage for Interactive Services
   - date: 2011

** ABSTRACT
   - Megastore is a storage system developed to meet the re-quirements of today’s interactive online services. Megas-tore blends the scalability of a NoSQL datastore with the convenience of a traditional RDBMS in a novel way, and provides both strong consistency guarantees and high avail-ability. （只要是为了满足现在交互式在线服务的存储需求，融合了NoSQL扩展性以及RDBMS的方便性，同时提供了强一致性以及高可用性）
   - We provide fully serializable ACID semantics within fine-grained partitions of data. This partitioning allows us to synchronously replicate each write across a wide area net-work with reasonable latency and support seamless failover between datacenters.（在一个数据区域上提供了完全的可串行化的ACID语义。在这个数据区域上面我们所有的写可以在WAN下面以非常小的延迟做同步replicate，同时支持datacenter之间的seamless failover）

** INTRODUCTION
   - We accomplish this by taking a middle ground in the RDBMS vs. NoSQL design space: we partition the data-store and replicate each partition separately, providing full ACID semantics within partitions, but only limited con-sistency guarantees across them. We provide traditional database features, such as secondary indexes, but only those features that can scale within user-tolerable latency limits, and only with the semantics that our partitioning scheme can support. 
     - 将数据进行partition，对于每个partition内部提供完全ACID语义的操作并且之间的replicate是强一致的，但是对于across partition仅仅是做到了有限的一致性（最终一致性？）
     - 同时提供了一些传统的db特性比如二级索引，但是这个feature可能会带来比较高的延迟，并且对应的语义是partition scheme（分区方案）所支持的（ /比如如果二级索引是跨partition的话，那么索引的更新是做不到原子的/ ）
   - Contrary to conventional wisdom [24, 28], we were able to use Paxos to build a highly available system that pro-vides reasonable latencies for interactive applications while synchronously replicating writes across geographically dis-tributed datacenters. While many systems use Paxos solely for locking, master election, or replication of metadata and configurations, we believe that Megastore is the largest sys-tem deployed that uses Paxos to replicate primary user data across datacenters on every write.（mega使用paxos来完成低延迟下跨地域的同步复制来构建高可用性的系统。大部分的系统都是使用paxos来做locking，master选举或者是备份一些metadata或者是配置文件，而mega对每次写都用paxos做跨数据中心的复制）

*NOTE（dirlt）：table schema主要是用来描述各个表存储结构。mega使用上更类似NoSQL*

** TOWARD AVAILABILITY AND SCALE
   - To do so, we have taken a two-pronged approach:
     - for availability, we implemented a synchronous, fault-tolerant log replicator optimized for long distance-links;（对于availablity使用同步容错的log replicator，为了长距离链接进行了优化。 /使用优化的Paxos/ ）
     - for scale, we partitioned data into a vast space of small databases, each with its own replicated log stored in a per-replica NoSQL datastore.（为了scale对于数据进行partition。各个partition有自己的replicated log，记录在自己所在的NoSQL datastore里面）

*** Replication
   - For cloud storage to meet availability demands, service providers must replicate data over a wide geographic area.（对于云存储必须满足可用性的需求，服务提供商必须跨地域进行replication），We evaluated common strategies for wide-area replication：（下面几个常见的跨地域replication解决方案）
     - Asynchronous Master/Slave 数据丢失风险，SPOF
     - Synchronous Master/Slave 延迟大，SPOF
     - Optimistic Replication 数据丢失风险并且不能够确定commit order，不能够做到ACID
   - We decided to use Paxos, a proven, optimal, fault-tolerant consensus algorithm with no requirement for a distinguished master. （paxos不需要单独的master）
     - We replicate a write-ahead log over a group of symmetric peers. Any node can initiate reads and writes. Each log append blocks on acknowledgments from a ma-jority of replicas, and replicas in the minority catch up as they are able—the algorithm’s inherent fault tolerance elim-inates the need for a distinguished “failed” state. （每个群组都有一个WAL，在群组里面所有的节点都可以发起read/write，只要大部分节点ack那么说明数据就写入了WAL返回成功，对于小部分没有ack的节点之后有办法跟上数据而不会造成不一致）
     - A novel extension to Paxos, detailed in Section 4.4.1, allows local reads at any up-to-date replica. Another extension permits single-roundtrip writes.（对于paxos进行了一些扩展，允许在任何一个up-to-date的节点上面进行local read，并且write只需要single-roundtrip）
     - *TODO（dirlt）：read paxos paper, then read this paper back*
   - Even with fault tolerance from Paxos, there are limita-tions to using a single log. With replicas spread over a wide area, communication latencies limit overall through-put. Moreover, progress is impeded when no replica is cur-rent or a majority fail to acknowledge writes. In a traditional SQL database hosting thousands or millions of users, us-ing a synchronously replicated log would risk interruptions of widespread impact . So to improve availability and throughput we use multiple replicated logs, each governing its own partition of the data set.（但是使用single log还是存在局限性。一方面因为跨地域进行replication那么延迟相当高 /我理解如果只有一个WAL的话，为了确保满足ACID性质那么所有的write必须是order的，这样所有的write都集中在一个WAL会导致latency非常高/ ，另外更重要的因素是如果没有足够的replica使用或者是大部分节点都failed to ack write的话，那么所有的write都会被block住，整个progress就停止了。所以为了提高可用性以及吞吐我们必须使用multiple replicated logs，每个partition都有各自的replicated log）

*** Partitioning and Locality
   - To scale throughput and localize outages, we partition our data into a collection of entity groups, each indepen-dently and synchronously replicated over a wide area. The underlying data is stored in a scalable NoSQL datastore in each datacenter (see Figure 1) 划分的每个单元称为entity group.
     - Entities within an entity group are mutated with single-phase ACID transactions (for which the commit record is replicated via Paxos).
     - Operations across entity groups could rely on expensive two-phase commits, but typically leverage Megastore’s efficient asynchronous messaging. 
     - A transac-tion in a sending entity group places one or more messages in a queue; transactions in receiving entity groups atomically consume those messages and apply ensuing mutations.
   - Indexes local to an entity group obey ACID semantics; those across entity groups have looser consistency. See Fig-ure 2 for the various operations on and between entity groups.





