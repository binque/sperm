* hbase
** FAQ
*** hbase shell
   - scan 'test'
   - scan 'test' , { LIMIT=>10 }
   - scan 'test' , { COLUMN=>['cf:url'] }
   - scan 'test' , { STARTROW=>'xyz' }
   - count 'test'

*** hbase increment
http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Increment.html

*** hbase join
http://stackoverflow.com/questions/11327316/how-to-join-tables-in-hbase

其实对于join来说无非三种：
   - sort join 两路排序，之后进行merge。
   - loop join 没有任何排序，直接循环匹配。
   - hash join 遍历一路的时候去查另外一路。

对于MR来说，个人认为sort join通常是效率最高的方式，而hash join次之（hbase的read效率不是很高）。

** View
*** 业强 2012-08-16 hbase讲座
file:./images/hbase-architecture.png


HRegion类似于tablet，每个HRegion有很多Store存储不同的column family。

对于memstore内存大小限制的话，有两个方面：
   - HRegion如果总体内存比较大的话，那么会选择几个Store里面的memstore进行flush
   - 如果Store里面的memstore本身比较大的话，也会进行flush

scan过程大致是这样的：
   - 首先scanner得到memstore以及所有的hfile，以及这个似乎时候的timestamp（hbase使用timestamp作为version)进行归并排序。
   - 如果期间memstore发生写，或者是flush，或者是进行compaction的话，那么会通知scanner
   - scanner会重新组织这些内容，根据上次读取到的value,忽路duplicated的数据。   
这样的好处就是通常在scanner的时候不会阻塞其他操作。

--------------------

但是我看了一下leveldb代码，觉得实现上更好。对于immutable memtable以及memtable做引用计数，在iterator里面保存两个table。
如果memtable compaction之后的话，那么直接创建一个新的memtable即可。原有的table在iterator销毁的时候就会自动释放。

--------------------

对于column family是可以设置超时时间的。在进行flush或者是compaction的时候，会判断这个value是否超过ttl。如果超过ttl的话那么就会直接丢弃。

*** asynchbase
https://github.com/stumbleupon/asynchbase

   - asynchbase和HTable的性能对比 http://www.tsunanet.net/~tsuna/asynchbase/benchmark/viz.html 
   - OpenTSDB is a distributed, scalable Time Series Database (TSDB)  http://opentsdb.net/index.html 

从看asynchbase介绍来看，我猜想asynchbase用在MR范围还是有限的。
   - asynchbase就是一个异步client，能够很好地解决一个app里面对于hbase有很多个连接的场景。
   - 但是在MR里面，拿我们现在的HourlyProcedure来说，每次get都是一个同步过程，一定要取回结果才能够进行下一步的操作。整个MR框架就限制了异步client的作用。
   - asynchbase现在使用的场景应该是OpenTSDB，因为没有MR框架限制，所以异步client可以工作很好。






