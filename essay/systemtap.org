* systemtap
   - SystemTap http://sourceware.org/systemtap/
   - SystemTap http://sourceware.org/systemtap/documentation.html
   - Linux 自检和 SystemTap http://www.ibm.com/developerworks/cn/linux/l-systemtap/
   - IBM Redbooks | SystemTap: Instrumenting the Linux Kernel for Analyzing Performance and Functional Problems http://www.redbooks.ibm.com/abstracts/redp4469.html
   - Architecture of systemtap a Linux trace probe tool http://sourceware.org/systemtap/archpaper.pdf
   - Dynamic Instrumentation of Production Systems http://static.usenix.org/event/usenix04/tech/general/full_papers/cantrill/cantrill_html/
   - sudo apt-get install systemtap # 直接使用apt安装
     - sudo apt-get install elfutils # 可能需要安装
   - *NOTE（dirlt）：linux还自带perf工具也能够观察kernel行为*

** Introduction
systemtap的工作原理是使用linux提供的kprobe接口 *TODO(dirlt):more about kprobe* ，将用户需要观测linux系统的行为转换成为c（使用kprobe)并且编译成为kernel object然后运行。 
systemtap使用一种触发式的工作方式，通过安装探针（probe）来监控系统的行为，一旦探针事件出现的话就会触发对应的代码。代码使用自己定义的语言，和C语言非常类似。

file:./images/systemtap-prepare-workflow.gif

   - stap 流程从将脚本转换成解析树开始 (pass 1)
   - 然后使用细化（elaboration）步骤 (pass 2) 中关于当前运行的内核的符号信息解析符号
   - 接下来转换流程将解析树转换成 C 源代码 (pass 3) 并使用解析后的信息和 tapset 脚本（SystemTap 定义的库，包含有用的功能）
   - stap 的最后步骤是构造使用本地内核模块构建进程的内核模块 (pass 4)。

file:./images/systemtap-run-workflow.gif

   - staprun 负责启动kernel object
   - stapio 负责收集kernel object的输出
   - 执行期间中断的话将执行清除进程，卸载模块并退出所有相关的实用程序

一个使用systemtap的简单例子
#+BEGIN_EXAMPLE
[dirlt@umeng-ubuntu-pc] >  sudo stap -ve 'probe begin { log("hello world") exit() }'
Pass 1: parsed user script and 76 library script(s) using 92476virt/22592res/2616shr kb, in 80usr/0sys/85real ms.
Pass 2: analyzed script: 1 probe(s), 2 function(s), 0 embed(s), 0 global(s) using 93000virt/23472res/2816shr kb, in 0usr/0sys/4real 
ms.                                                                                                                                
Pass 3: translated to C into "/tmp/stapbx8Gpk/stap_7703b9bd08bd359932cf8da12019f6d8_813.c" using 93000virt/23628res/2964shr kb, in 0
usr/0sys/0real ms.                                                                                                                 
Pass 4: compiled C into "stap_7703b9bd08bd359932cf8da12019f6d8_813.ko" in 3240usr/510sys/4048real ms.
Pass 5: starting run.
hello world
Pass 5: run completed in 10usr/10sys/600real ms.

[dirlt@umeng-ubuntu-pc] >  sudo stap -ve 'probe begin { log("hello world") exit() }'
Pass 1: parsed user script and 76 library script(s) using 92476virt/22592res/2616shr kb, in 80usr/10sys/85real ms.
Pass 2: analyzed script: 1 probe(s), 2 function(s), 0 embed(s), 0 global(s) using 93000virt/23472res/2816shr kb, in 0usr/0sys/4real 
ms.                                                                                                                                
Pass 3: using cached /home/dirlt/.systemtap/cache/77/stap_7703b9bd08bd359932cf8da12019f6d8_813.c
Pass 4: using cached /home/dirlt/.systemtap/cache/77/stap_7703b9bd08bd359932cf8da12019f6d8_813.ko
Pass 5: starting run.
hello world
Pass 5: run completed in 0usr/10sys/586real ms.
#+END_EXAMPLE
可以看到在第二次运行的时候systemtap会去读取缓存内容。

** probe
TODO(dirlt):

** language
TODO(dirlt):

