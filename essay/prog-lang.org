* prog-lang
#+OPTIONS: H:5

** overview
*** 编程语言要素
所谓编程语言要素就是说，一旦我们对于这些编程语言的要素掌握之后，我们就可以用这个语言做一些事情了。编程语言要素必须是基本的(atomic)，
然后我们在学习语言的时候，首先学习这些基本的内容之后，就可以开动了。不要使用形式的东西来概括，必须是一些可以put into practice的东西

   - 基本类型 // 比如字符串如何表示等
   - 复合结构 // 如何将基本类型复合出来
   - 内存管理 // 如何进行内存分配释放
   - 程序结构 // 变量作用域，变量声明，类的访问权限，程序结构
   - 语言特有特性 // 反射，动态代码生成，continuation
   - 工程组织性 // 如何组织一个大的项目，如何服用代码比如库
   - 文件系统 // 如何操作文件，读取特定字节等
   - 并发控制 // 比如进程，线程，锁
   - 网络通信 // 通讯设施
   - C/C++扩展 // 如何使用C/C++来编写扩展提高效率

*** 语言的特征
一种语言并不会因为拥有其他语言所没有的特征，就比其他的语言更好。重要的问题并不在于语言有多少特征，而在于它所拥有的特征是否足以在某个希望的应用领域支持某种所希望的程序设计风格
   - 所有特征必须清晰优雅地集成在语言中
   - 能够组合这些特征得到一个解决方案
   - 减少荒谬和专用的特征
   - 任何特征的实现都不应该给未使用该特征的程序强加上明显的额外开销
   - 用户只需要了解自己在编写程序时所明确使用的那个语言子集 

** cpp
*** 相关资料
  - The C Programming Language(DMR & BWK)
  - C and Pointers
  - The C++ Programming Language(BS)
  - Thinking in C++
  - http://www.cplusplus.com/doc/tutorial/

*** TC++PL
学习C++时，最主要的事情就是集中关注概念，不要迷失在语言的技术细节里面，学习语言的目的是成为一个更好的程序员，对于程序设计和设计技术的理解远远比语言细节重要.在实践性程序设计中，理解语言中最晦涩难懂的语言特征或者使用大量的不同特征并不能够获得什么利益:-).C++支持一种逐步推进的学习方式，就是说一开始就可以来使用C++编写实际的东西，同时C++支持多种程序设计范型，能够使得你大致线形地学习它的概念，并且在学习过程中不断收到实际效益。

OOP允许程序员用问题本身的属于来描述问题，而不是要用运行解决方案的计算机术语来描述问题。人们已经对OOP语言有了这样的看法，就是程序员应该抛弃所知道的所有事情并且从一组新的概念和文法重新开始，程序员应当相信从长远观点来看，最好还是丢掉所有来自过程语言的老行装。没错从长远观点来看，这是对的，但是从短期角度来看，这些行装确实有价值的。C++成功的原因是很经济的，转变到OOP需要代价但是C++尽可能让代价小。

关于C++标准库的忠告:
   - 不要像重新发明轮子一样去做每一件事情，使用库。
   - 不要相信奇迹，理解你的库能够做什么如何做，代价多大。
   - 不要认为为标准库对于任何事情都是最理想的。

*** local static object
局部静态对象在C里面初始化只允许是常数，所以这个在编译期就可以搞定。在C++里面局部静态对象允许是一个类对象，那么就涉及到类的初始化等问题，这个是在编译期搞不定的只能够在运行期解决。

#+BEGIN_SRC C++
#include <iostream>
class A{
 public:
  A(){
    std::cout << "A()" << std::endl;
  }
};
void foo(){
  static A a;  
}
int main(){
  foo();
  return 0;
}
#+END_SRC

我们考虑局部静态对象的初始化时机。如果仅仅是在程序启动时候就初始化的话那么肯定不合适，所以肯定是在第一次调用foo时候进行初始化(这里还需要考虑多线程问题).我们可以看看这个部分汇编代码.对于a对象的话好比存在一个instance_counter初始化为0.首先判断是否初始化了，然后会调用__cxa_guard_acquire加锁然后再判断一次(double check,可以减少开销），最后使用__cxa_guard_release释放这个锁。

#+BEGIN_SRC ASM
.globl _Z3foov
	.type	_Z3foov, @function
_Z3foov:
.LFB1445:
	pushq	%rbp
.LCFI3:
	movq	%rsp, %rbp
.LCFI4:
	subq	$32, %rsp
.LCFI5:
	cmpb	$0, _ZGVZ3foovE1a(%rip) 
	jne	.L10
	movl	$_ZGVZ3foovE1a, %edi
	call	__cxa_guard_acquire 
	testl	%eax, %eax
	je	.L10
	movb	$0, -1(%rbp)
	movl	$_ZZ3foovE1a, %edi
.LEHB0:
	call	_ZN1AC1Ev
.LEHE0:
	movl	$_ZGVZ3foovE1a, %edi
	call	__cxa_guard_release 
	jmp	.L10
.L19:
	movq	%rax, -24(%rbp)
.L13:
	movq	-24(%rbp), %rax
	movq	%rax, -16(%rbp)
	cmpb	$0, -1(%rbp)
	je	.L15
	jmp	.L16
.L15:
	movl	$_ZGVZ3foovE1a, %edi
	call	__cxa_guard_abort
.L16:
	movq	-16(%rbp), %rax
	movq	%rax, -24(%rbp)
.L17:
	movq	-24(%rbp), %rdi
.LEHB1:
	call	_Unwind_Resume
.LEHE1:
.L10:
	leave
	ret
#+END_SRC

*** hook function
hook函数调用有两种方式，一种是hook我们代码内部的函数，这意味这这个函数是由我们来编译的，当然我们不能够修改需要hook的函数实现否则就没有意义了。另外一种hook函数是动态库里面的函数，静态库里面的函数因为完全进入了可执行程序，所以修改起来比较麻烦一些。我们QA写过这样的程序用libbfd库修改可执行程序本身，在函数调用之间加上跳板，但是相比本文介绍的两种方式更加复杂。（复杂就以为着容易出错，而且这种修改可执行程序应该是不值得提倡的）。

--------------------
hook编译时函数

在gcc编译的时候需要加入-finstrument-functions这个选项之后，那么每个函数调用之前和之后都会调用
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit 
这两个函数是gcc内置函数，_enter函数能够在函数调用之前进行调用，_exit函数能够在函数调用退出之后调用，原型分别是
#+BEGIN_SRC C++
// this是这个callee函数地址
// callsite是caller函数调用点地址(不是函数地址)
void __cyg_profile_func_enter(void *this, void *callsite);
void __cyg_profile_func_exit(void *this, void *callsite);
#+END_SRC

如果不希望函数被hook的话，那么可以在函数属性之后加上__attribute__((no_instrument_function)).尤其是这个函数如果在enter和exit里面调用的话，最好加上这个属性，不然非常容易出现递归调用

#+BEGIN_SRC C++
#include <cstdio>
#include <cstdlib>
void foo() __attribute__((no_instrument_function));
void foo() {
    printf("%s\n",__func__);
}
int main() {
    printf("main\n");
    return 0;
}
extern "C" {
    void __cyg_profile_func_enter(void* callee, void* callsite)  __attribute__((no_instrument_function));
    void __cyg_profile_func_exit(void* callee, void* callsite) __attribute__((no_instrument_function));
    void __cyg_profile_func_enter(void* callee, void* callsite) {
        foo();
    }
    void __cyg_profile_func_exit(void* callee, void* callsite){
        foo();
    }
}
#+END_SRC

--------------------
hook运行时函数

可以使用dlopen截获函数入口，然后使用dlsym(RTLD_NEXT)来获得下一个入口.我们以截获malloc为例。
#+BEGIN_SRC C++
#include <unistd.h>
#include <dlfcn.h>
#include <cstring>
#include <cstdlib>

void* malloc(size_t size){
    write(2,"do malloc\n",strlen("do malloc\n")+1); // 这里不能够用printf,因为内部可能会调用malloc
    static void* (*pmalloc)(size_t size)=0;
    if(!pmalloc){        
        pmalloc=(void*(*)(size_t size))(dlsym(RTLD_NEXT,"malloc"));
    }
    return pmalloc(size);
}

void free(void *p){
    write(2,"do free\n",strlen("do free\n")+1);
    static void (*pfree)(void* p)=0;    
    if(!pfree){        
        pfree=(void(*)(void* p))(dlsym(RTLD_NEXT,"free"));
    }
    return pfree(p);
}
#+END_SRC

*** 编译可运行的.so
#+BEGIN_SRC C++
#include <cstdio>
#include <cstdlib>

#ifndef BEGIN_DECLS
#ifdef __cplusplus
#define BEGIN_DECLS extern "C" {
#define END_DECLS }
#else
#define BEGIN_DECLS
#define BEGIN_DECLS
#endif
#endif

BEGIN_DECLS
#ifndef __i386
#define LD_SO_PATH "/lib64/ld-linux-x86-64.so.2"
#else
#define LD_SO_PATH "/lib/ld-linux.so.2"
#endif

#if defined(__DATE__) && defined(__TIME__)
#define BUILD_DATE  (__DATE__ " " __TIME__)
#else
#define BUILD_DATE  "unknown"
#endif

const char interp[] __attribute__((section(".interp"))) = LD_SO_PATH;
void so_main() {
  printf("LD_SO_PATH : %s\n", LD_SO_PATH);
  printf("BuildDate : %s\n", BUILD_DATE);
  exit(0);
}

END_DECLS
#+END_SRC

*** undefined reference to static const class member
类型静态常量成员只允许是标量内容,而不允许是字符串数组或者是结构体等。但是下面代码会存在链接问题

#+BEGIN_SRC C++
#include <vector>
using namespace std;
class Foo {
 public:
  static const int MEMBER = 1;
};

int main(){
  vector<int> v;
  v.push_back( Foo::MEMBER );       // undefined reference to `Foo::MEMBER'
  v.push_back( (int) Foo::MEMBER ); // OK
  return 0;
}
#+END_SRC

关于这个问题解释可以参看 http://stackoverflow.com/questions/272900/c-undefined-reference-to-static-class-member

大致解释是这样，对于第一种用法的话，因为push_back需要是一个const int&,因为需要传入的内容存在地址。而这种情况下面MEMBER仅仅是一个constant,没有任何地址所以会出现链接错误。而对于第二种情况的话，因为强制转换之后那么就存在一个临时对象可以被引用。说到这里我们一定需要注意临时对象，好比下面这种用法
#+BEGIN_SRC C++
#include <string>
int main() {
  std::string s1="h";
  std::string s2="o";
  const char* s=(s1+s2).c_str();
  return 0;
}
#+END_SRC
这里(s1+s2)生成了一个临时对象但是却没有存放的内容，所以后续继续引用s是会出问题的。

*** new/delete
new/delete和C的内存分配有很多区别，主要的改进在进行了很多可定制化的内容:
   * new/delete作为运算符而不是函数存在，因此可以重载来进行内存分配的定制
   * 在new/delete对象的时候会调用分配对象的构造和析构函数
   * new/delete对象的时候区分了new/delete和new/delete [](主要原因还是因为需要调用构造和析构函数):-)
   * 支持放置语法，就是传入一个信息告诉分配函数希望在哪个地方进行分配
   * 加入了异常分配失败抛出bad_alloc
   * 提供了一种方法设置handler在分配失败的时候调用set_new_handler()
   * 默认的new还进行检查以确信在传递地址给构造函数之前内存分配成功
   * 允许重载全局new/delete和某个类的new/delete 

--------------------
new重载

用户可以重载new/delete来实现全局new/delete或者是某个类的new/delete.原型有下面这些
#+BEGIN_SRC C++
// #include <new>
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();

// Default placement versions of operator new.
inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }

// Default placement versions of operator delete.
inline void  operator delete  (void*, void*) throw() { }
inline void  operator delete[](void*, void*) throw() { }
#+END_SRC

new/delete如果作为类成员的话被重载的话，始终是静态成员，即使你不这样声明也是如此，这个事实意味着这些运算符不接受this指针。其实这也是非常容易考虑到的，new/delete本来就是来分配内存使用的。new在初始化构造之前调用，而delete是在析构函数调用之后调用，所以非静态数据成员肯定不能够被访问:-)此外new/delete是可以继承的,调用的还是基类的new/delete函数，只不过内存大小不同。

#+BEGIN_SRC C++
#include <iostream>
#include <new>
class A{
 public:
  void* operator new(size_t s,int arg) throw(std::bad_alloc) {
    std::cout << "size : " << s << ", arg : " << arg << std::endl;
    return ::operator new(s);
  }
  void* operator new(size_t s,int arg,const std::nothrow_t& nothrow){
    std::cout << "[nothrow]size : " << s << ", arg : " << arg << std::endl;
    return ::operator new(s,nothrow);
  }
  void operator delete(void* p) {
    ::operator delete(p);
  }
  int x;
};
class B: public A{
  int y;
};

int main(){
  A* a=new (10,std::nothrow)A();
  B* b=new (20)B();
  delete a;
  delete b;
}
#+END_SRC

--------------------
new异常规格

从new的异常规格可以看到，如果是普通的调用的话可能会抛出std::bad_alloc这个异常，但是原型里面还有
#+BEGIN_SRC C++
void* operator new(std::size_t, const std::nothrow_t&) throw(); 
#+END_SRC
这种使用placement来通知new不抛出异常的的接口，语义是返回NULL来告诉app分配失败。要使用这个函数也非常简单
#+BEGIN_SRC C++
// #include <new>
//  struct nothrow_t { };
//  extern const nothrow_t nothrow;
void* p=new (std::nothrow) int(); // 这里std::nothrow就是std::nothrow_t的实例
#+END_SRC
通过函数重载来达到这个目的，这个方法值得借鉴。

--------------------
内存分配失败

C++来提供了内存分配失败的回调函数，但是这个只能够处理全局new分配失败的情况
#+BEGIN_SRC C++
  /** If you write your own error handler to be called by @c new, it must
   *  be of this type.  */
  typedef void (*new_handler)();
  /// Takes a replacement handler as the argument, returns the previous handler.
  new_handler set_new_handler(new_handler) throw();
#+END_SRC

--------------------
operator new与new operator

此外在很多书籍里面会提到operator new和new operator这两个说法，这两个是不一样的概念。operator new就是我们重写运算符函数，而new operator使我们调用new这个表达式。本质上说new这个表达式调用了分配类型里面的operator new函数，同时调用这个类型的初始化构造函数。同理operator delete和delete operator差别也是一样的。通常new operator的动作是这样的:
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
同理通常delete operator的动作是这样的:
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
说到这里，我们需要清楚为什么需要有new []和delete []的方法了。对于operator new和delete来说真的不关心这些，因为只是分配内存，而对于new operator和delete operator就需要关心了，因为需要关心有多少个对象，这样的话才能够调用每个对象的构造函数。调用了new []分配的对象也一定需要使用delete []来释放，不然只会调用第一个元素析构函数和释放它的空间。

*** static assert
#+BEGIN_SRC C++
#define STATIC_ASSERT(_cond,_name)      typedef char STATIC_ASSERT_FAILED_ ## _name [ (_cond) ? 1 : -1 ]
#define STATIC_SIZE_ASSERT(_type,_size) STATIC_ASSERT ( sizeof(_type)==_size, _type ## _MUST_BE_ ## _size ## _BYTES )
#+END_SRC

这个宏用来检测sizeof(_type)==_size这个假设，这个可以在编译代码的时候可以进行断言。好比下面这段程序

#+BEGIN_SRC C++
int main() {
  STATIC_SIZE_ASSERT(int,8);
  return 0;
}
#+END_SRC

那么编译就会出现
#+BEGIN_EXAMPLE
main.cc:5: error: size of array `STATIC_ASSERT_FAILED_int_MUST_BE_8_BYTES’ is negative
#+END_EXAMPLE

当然错误信息并不是非常的优美，但是已经提供了足够多的信息了。不过这种编译断言可能只是比较适合用于简单断言比如sizeof等，对于复杂断言话可能还是需要依赖于configure这种工具比如系统是否有libunwind库。


** java
*** 相关资料
   - Core Java Volume I: Fundamentals

** clojure
*** 相关资料
   - http://clojure.org/
   - http://clojure.github.com/clojure/
   - http://java.ociweb.com/mark/clojure/

** python
*** encode/decode
python字符串是unicode类型，二进制是str类型。
   - encode是将unicode转换成为str
   - decode是将str转换成为unicode
#+BEGIN_EXAMPLE
>>> a="中国"
>>> a
'\xe4\xb8\xad\xe5\x9b\xbd'
>>> a.decode('utf8')
u'\u4e2d\u56fd'
>>> print a.decode('utf8')
中国
>>> print a.decode('gb18030')
涓浗
#+END_EXAMPLE

这里一个比较难处理的问题就是字符编码的识别，这个在我的项目[[file:./dsgm.org][dsgm]] 遇到过。个人现在处理的办法就是尝试全部转换成为utf8来进行处理。实现办法就是首先尝试转换
到gb18030,如果转换失败的话那么转换成为utf8（当然这不是最好的，使用chardet这样的模块似乎是更合理的选择），这样的操作对于我们中国大陆用户来说基本上应该
OK，就我所知道的系统XP都是GB2312编码，linux/mac通常设置成为utf8，而cygwin这样架在windows上面的系统通常也是gb2312。

#+BEGIN_SRC Python
def toUTF8(s):
    try:
        # detect gb2312 first.
        return s.decode('gb2312').encode('utf8')
    except UnicodeDecodeError,e:
        return s
        
def toLocal(s):
    try:
        open(s,'r') # what a tricky way.
        return s
    except IOError,e:
        if(e.errno==22): # errno.EINVAL
            return s.decode('utf8').encode('gb2312')
        return s
#+END_SRC
对于从本地转换出去的话，我们首先尝试使用gb2312进行decode，如果失败的话那么就认为是utf8编码，当然这里会有一定的错误机率（但是不大）。
转换到本地的话，我们唯一不确定的就是本地是utf8格式还是gb2312格式。可以通过尝试打开一个文件来判断，其中22是errno.EINVAL的错误编码。
如果字符编码错误的话，那么返回的就是invalid argument的错误，同样会存在一定错误机率（但是不大）。出现错误几率的原因就是这些码点，使用
gb2312可以正常解释，使用utf8也可以正常解释。

** scheme
*** 相关资料
   - [[http://mitpress.mit.edu/sicp/][Structure and Interpretation of Computer Programs]]

*** SICP
绝不要认为似乎成功计算机的钥匙就掌握在你的手里。你所掌握的,也是我认为并且希望的,也就是智慧:那种看到这一机器比你第一次站在它面前时能够做的更多的能力，这样你才能将它向前推进。

一台计算机就像是把小提琴。你可以想象一个新手试了一个音符并且立刻丢弃它。后来他说，听起来真难听。我们已经从大众和我们的大部分计算机科学家那里反复听到这种说法。他们说，计算机程序对个别具体用途而言确实是好东西，但是他们太缺乏弹性了。一把小提琴或者是一台打字机也能够同样缺乏弹性，那时你学会了如何使用它们之前。

心智的活动除了尽力产生各种简单的认识外，主要表现在(组合，对比，抽象):
   1. 将若干简单认识组合称为复合认识，由此产生复杂的认识
   2. 将两个认识放在一起对照，不管简单还是复杂，由此得到它们之间的相互关系的认识
   3. 将有关认识和实际中和它们所在的认识隔离开，就是抽象，所有具有普遍性的认识都是这样得到的。

现在到了数学抽象中最关键的一步:让我们忘记这些符号所表示的对象。数学家不应该在这里停步，有许多操作可以应用于这些符号，而根本不必考虑它们代表什么。

建立新语言是在工程设计中控制复杂性的一种威力强大的工作策略，通常能够采用一种新语言提升处理复杂问题的能力，因为新语言能够使我们以一种完全不同的方式，利用不同原语组合方式和抽象方式去描述(思考)所面临的问题。

NOTE(dirlt):[[http://mitpress.mit.edu/sicp/][SICP]] 大四时候就看到了，当时只是觉得封面很有神秘感，里面的代码似乎和我以前写过的代码方式差别很大，当时没有完全看懂（现在也没有完全看懂，不确定求值没有看懂，第五章没有静下心看）。对于语言层面的认识基本上忘了，只记得有惰性求值来解决流问题，正则序和应用序，eval+apply是程序运行过程等。但是当时有一点让我印象深刻，就是这么简单的语言能够组合得这么强大并且如此具有表示力。

*** church counter
只要能够正确理解计数就可以，并不一定要将这个数显示出来

#+BEGIN_SRC scheme
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x)))))
#+END_SRC

我们把zero带入add-1
#+BEGIN_EXAMPLE
(lambda (f) (lambda (x) (f ((lambda (f) (lambda (x) x)) f) x)))
 => (lambda (f) (lambda (x) (f ((lambda (x) x) x))))
 => (lambda (f) (lambda (x) (f x)))
#+END_EXAMPLE
这个时候我们可以和zero比较，就会发现里面多了一次f操作，这就是计数操作

对于one two的定义，可以写为
#+BEGIN_SRC scheme
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))
#+END_SRC
对于(add m n)定义可以写为
#+BEGIN_SRC scheme
(define (add m n) (lambda (f) (lambda (x) ((m f) ((n f) x)))))
#+END_SRC

