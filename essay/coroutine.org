* coroutine
   - [[http://en.wikipedia.org/wiki/Coroutine][Wikipedia Coroutine]]
   - [[http://en.wikipedia.org/wiki/Continuation][Wikipedia Continuation]]
   - [[http://en.wikipedia.org/wiki/Green_threads][Wikipedia Green Threads（绿色线程）]]
   - [[http://www.gnu.org/software/pth/][GNU portable thread（比较重）]]
   - [[http://www.xmailserver.org/libpcl.html][portable coroutine library(个人比较推荐）]]
   - [[http://software.schmorp.de/pkg/libcoro.html][libcoro]]
   - [[http://www.goron.de/~froese/coro/][coro]]
   - [[http://code.google.com/p/libconcurrency/][libconcurrency]]
   - [[http://swtch.com/libtask/][libtask（封装了阻塞接口配合coroutine）]]
   - [[http://www.dekorte.com/projects/opensource/libcoroutine/][libcoroutine]]
   - [[http://www.csl.mtu.edu/cs4411.ck/www/NOTES/non-local-goto/coroutine.html][coroutine过程演示（推荐阅读）]]
   - [[http://blog.rethinkdb.com/improving-a-large-c-project-with-coroutines][Improving a large C++ project with coroutines（如何使用coroutine实践）]]

coroutine，windows编程里面的纤程（fiber）,绿色线程（green thread），Erlang里面的轻量进程(lightweight process)，其实实现上就是从栈空间跳转到另外一个栈空间进行执行，并且这个触发动作是由用户发起的。当然线程也是这样实现的，只不过linux NTPL是内核态线程实现(coroutine也可以认为是用户态线程，所以GNU portable thread就是这个理念），之间切换是由内核来触发的。内核态触发通常是由于线程时间片到，发现阻塞。内核态的切换都是强制切换。但是内核态切换太耗了，如果可以在用户态做就好了。
   1. 检测到阻塞，这个用户态可以完成。比如发起网络磁盘IO的话，如果会阻塞，我们就可以切换到其他coroutine直到发现不会阻塞再切换回来（当然实现上需要有一个调度coroutine).
   2. 检测时间片进行强制切换，这点在用户态是做不到的。所以试图在C/C++引入coroutine的话，如果一个coroutine CPU时间很长的话，那么可能会影响到其他coroutine的时间，因为在用户态做不到公平。但是如果引入虚拟机的话，这个问题就可以解决了，虚拟机代替我们的操作系统来进行时间分片。

