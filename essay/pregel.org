* pregel
   - http://kowshik.github.com/JPregel/pregel_paper.pdf
   - JPregel @ GitHub http://kowshik.github.com/JPregel/ 
   - Pregel: Google’s other data-processing infrastructure  http://www.royans.net/arch/pregel-googles-other-data-processing-infrastructure/
   - Pregel: A System for Large-Scale Graph Processing http://www.slideshare.net/shatteredNirvana/pregel-a-system-for-largescale-graph-processing

   - title: Pregel: A System for Large-Scale Graph Processing
   - authors: {malewicz,austern,ajcbik,dehnert,ilan,naty,gczaj}@google.com
   - date: 2010

*The name honors Leonhard Euler. The Bridges of Konigsberg, which inspired his famous theorem, spanned the Pregel river* （Euler回路起源就是Konigsberg桥问题，而这个桥就在Pregel River上面）

** Abstract
   -  Programs are expressed as a sequence of iterations, in each of which a vertex can receive messages sent in the previous iteration, send mes-sages to other vertices, and modify its own state and that of its outgoing edges or mutate graph topology. (主要是为了解决大规模图算法的问题。程序分为多次迭代地执行，每次迭代在顶点上面处理上次迭代接受到的消息，产生消息发送到其他节点，并且修改自身的状态，或者修改其出边，或者是修改整个图的拓扑结构)

** Introduction
   - The Internet made the Web graph a popular object of analysis and research. Web 2.0 fueled interest in social net-works. Other large graphs—for example induced by trans-portation routes, similarity of newspaper articles, paths of disease outbreaks, or citation relationships among published scientific work—have been processed for decades. （相当数量大规模图算法的应用）
   - Efficient processing of large graphs is challenging. （图算法本身特点，这些在设计框架的时候需要考虑）
     - Graph algorithms often exhibit poor locality of memory access, （locality非常差，需要访问其他节点产生的数据）
     - very little work per vertex, and （每个节点计算量并不大，主要还是多轮大量节点的迭代效果）
     - a changing degree of parallelism over the course of execution [31, 39]. （在执行过程中需要不断地修改并行度/图的拓扑结构）
   - Distribution over many machines exacerbates the locality issue, and increases the probability that a machine will fail during computation.（分布式需要考虑locality问题，并且还需要failover的情况）
   - MapReduce [14，], for example, is a very good fit for a wide array of large-scale computing problems. It is sometimes used to mine large graphs [11, 30], but this can lead to sub-optimal performance and usability issues. The basic models for processing data have been extended to fa-cilitate aggregation [41，] and SQL-like queries [40, 47], but these extensions are usually not ideal for graph al-gorithms that often better fit a message passing model.（对于MR来说非常适合大规模的计算问题，并且有时候能够用来最一些挖掘工作，但是并不是最优的解决方案，并且还需要考虑一些可用性问题。本质上对于图算法来说的话，使用消息传递机制会更加合适。/另外MR计算方式和图算法似乎还需要一个转换过程，而并不是intuitive的）

--------------------

   - Pregel computations consist of a sequence of iterations, called su-persteps. During a superstep the framework invokes a user-defined function for each vertex, conceptually in parallel. （每次迭代称为superstep，在每个superstep框架会调用每个vertex的自定义函数，这个过程是并行都的）
   - The function specifies behavior at a single vertex V and a single superstep S. It can read messages sent to V in su-perstep S − 1, send messages to other vertices that will be received at superstep S + 1, and modify the state of V and its outgoing edges. （每个节点会读取S-1时候其他节点发送给它的小心，处理完成之后就可以向其他节点发送消息，让这些节点在S+1时候处理。同时还可以修改整个图的拓扑结构）
   - Messages are typically sent along outgo-ing edges, but a message may be sent to any vertex whose identifier is known.（message并不一定是要随着outgoing edges，而是可以发送到任何节点）。
   - The vertex-centric approach is reminiscent of MapReduce in that users focus on a local action, processing each item independently, and the system composes these actions to lift computation to a large dataset. By design the model is well suited for distributed implementations: it doesn’t expose any mechanism for detecting order of execution within a superstep, and all communication is from superstep S to superstep S + 1.（以节点为中心的设计方式和MR非常像，用户只需要关于一个本地计算，对于每个item单独处理然后合并在一起形成一个大数据。这种设计是非常适合分布式的，对于一个superstep内部来说没有定义执行顺序，所有通信都是从S-》S+1之间的）
   - The synchronicity of this model makes it easier to reason about program semantics when implementing algorithms, and ensures that Pregel programs are inherently free of dead-locks and data races common in asynchronous systems.（以同步的方式可以更好地对program进行reason，并且可以使得整个系统避免死锁）
   - In principle the performance of Pregel programs should be com-petitive with that of asynchronous systems given enough parallel slack [28, 34]. Because typical graph computations have many more vertices than machines, one should be able to balance the machine loads so that the synchronization between supersteps does not add excessive latency. *TODO（dirlt）：怎么定义异步模式？是否如果工作异步模式的话，就没有superstep这个概念？* （因为节点数目远大于机器，因此整个分布式非常均匀的，因此采用同步的方式并不会带来太多的延迟，大部分节点完成时间是相同的，不会存在某个节点计算时间过长，否则采用异步方式会使得延迟更小。） *NOTE（dirlt）：但是异步方式会使得程序更加难懂，因为缺少一个barrier，V1可能计算到了Step3，而V2可能只是计算到Step1。此外也比较难确定一个节点什么时候需要计算下一轮，需要很多额外的描述*

** Model of Computation
   - The input to a Pregel computation is a directed graph in which each vertex is uniquely identified by a string vertex identifier. Each vertex is associated with a modifiable, user defined value. The directed edges are associated with their source vertices, and each edge consists of a modifiable, user defined value and a target vertex identifier.（pregel的输入就是一个有向图，每个节点都有一个唯一标识，并且有一个相应的自定义可修改数据。edge对应了source和target vertex，并且上面也有自定义数据） 。 但是注意 *Edges are not first-class citizens in this model, having no associated computation.* 对于edge来说并不是first-class，pregel是vertex-centric模式，edge上面没有对应任何计算。 *NOTE（dirlt）：不过既然vertex为中心，就没有必要指定edge上的输入吧！
   - A typical Pregel computation consists of input, when the graph is initialized, followed by a sequence of supersteps sep-arated by global synchronization points until the algorithm terminates, and finishing with output.（有一个全局的同步点机制，每轮迭代都会进行同步）
   - Within each superstep the vertices compute in parallel, each executing the same user-defined function that expresses the logic of a given algorithm. A vertex can modify its state or that of its outgoing edges, receive messages sent to it in the previous superstep, send messages to other vertices (to be received in the next superstep), or even mutate the topology of the graph.（在每一个superstep里面每个节点都会指定自定义函数，节点可以修改自身状态以及出口，接受上一步产生的信息并且写新的消息到其他节点，甚至修改全局拓扑）。 *NOTE（dirlt）：修改全局拓扑似乎是一个比较难实现的东西*
   - Algorithm termination is based on every vertex voting to halt. In superstep 0, every vertex is in the active state; all active vertices participate in the computation of any given superstep. A vertex deactivates itself by voting to halt. This means that the vertex has no further work to do unless trig-gered externally, and the Pregel framework will not execute that vertex in subsequent supersteps unless it receives a mes-sage. If reactivated by a message, a vertex must explicitly deactivate itself again. The algorithm as a whole terminates when all vertices are simultaneously inactive and there are no messages in transit.（起初每个节点都是active的，节点变为inactive需要自己vote to halt，这样节点下次就不会参与计算了。但是如果其他节点向这个节点发送消息的话，那么又会从inactive变为active状态。因此pregel的终止状态是所有节点都已经vote to halt并且没有任何message流动）
   - The output of a Pregel program is the set of values ex-plicitly output by the vertices. It is often a directed graph isomorphic to the input, but this is not a necessary prop-erty of the system because vertices and edges can be added and removed during computation. A clustering algorithm, for example, might generate a small set of disconnected ver-tices selected from a large graph. A graph mining algorithm might simply output aggregated statistics mined from the graph.（通常pregel的输出是是一个图，每个节点上面都有对应的value，图和原图是同构的。但是也不排除一些算法会修改图的结构，比如簇集算法或者图挖掘算法等）
   - We chose a pure message passing model, omitting remote reads and other ways of emulating shared memory, for two reasons. （选择消息传递模型而不是模拟共享内存的方式，主要有下面两点原因）
     - First, message passing is sufficiently expressive that there is no need for remote reads. We have not found any graph algorithms for which message passing is insufficient. （够用）
     - Second, this choice is better for performance. In a cluster environment, reading a value from a remote machine in-curs high latency that can’t easily be hidden. Our message passing model allows us to amortize latency by delivering messages asynchronously in batches.（能够隐藏一些延迟，比如能够通过batch方式，并且进行异步发送）
   - Graph algorithms can be written as a series of chained MapReduce invocations [11, 30]. We chose a different model for reasons of usability and performance. （虽然pregel可以使用系列的MR完成，但是考虑可用性以及性能使用另外模型）：
     - Pregel keeps ver-tices and edges on the machine that performs computation, and uses network transfers only for messages. （所有节点和边都是保存好的）
     - MapReduce, however, is essentially functional, so expressing a graph algo-rithm as a chained MapReduce requires passing the entire state of the graph from one stage to the next—in general requiring much more communication and associated serial-ization overhead（虽然MR是函数式的，但是每次都需要传递整个graph数据结构，这样会给通信以及序列话带来很多额外的开销）
     - In addition, the need to coordinate the steps of a chained MapReduce adds programming complex-ity that is avoided by Pregel’s iteration over supersteps.（使用MR还需要其他协调机制来保证同步，而pregel可以通过基于superstep的iteration来解决）

** The C++ API
#+BEGIN_SRC C++
template <typename VertexValue,
          typename EdgeValue,
          typename MessageValue>
class Vertex {
 public:
  virtual void Compute(MessageIterator* msgs) = 0; // 可以迭代发送给这个节点的消息
  const string& vertex_id() const; // 自身
  int64 superstep() const; // 迭代次数
  const VertexValue& GetValue(); // 自身hold value，custom。
  VertexValue* MutableValue();
  OutEdgeIterator GetOutEdgeIterator(); // out going vertices。这个也算是vertex hold value，builtin。
  void SendMessageTo(const string& dest_vertex, // 给某个节点发送消息
                     const MessageValue& message);
  void VoteToHalt(); // vote to halt
};
#+END_SRC
   - The values associated with the vertex and its edges are the only per-vertex state that persists across supersteps. Lim-iting the graph state managed by the framework to a single value per vertex or edge simplifies the main computation cycle, graph distribution, and failure recovery.（一个节点持有的value以及对应的edges是每次superstep需要保存的东西，这样可以简化框架所需要完成的工作，包括计算，图分布以及故障恢复）

*** Message Passing
   - When the destination vertex of any message does not ex-ist, we execute user-defined handlers. A handler could, for example, create the missing vertex or remove the dangling edge from its source vertex. *TODO（dirlt）：这点很重要，但是似乎做得不是很好。首先vertex应该是知道哪些节点是存在还是不存在的，不过这还是有一个问题，就是如何保证原子操作。因为可能有多个vertex会创建相同节点。另外就是这handler仅仅是在dest vertex不存在的时候才调用的，不能够主动地出发删除edge的操作* 
     - 我的理解是直接提供添加和删除vertex的接口，但是需要考虑到有多个节点共同操作的问题。 *NOTE（dirlt）：不过我看论文后面也讨论了这个问题*
     - 后面倒是说明白了，handler接口仅仅是为了在冲突的时候调用的，而并不是类似于回调的机制。

*** Combiners
   - 这个概念和MR里面非常类似，能够有效地减少数据传输量。我猜想combiner工作集合应该是节点发送给某个节点所有消息。
   - There are no guarantees about which (if any) messages are combined, the groupings presented to the combiner, or the order of combining, so combiners should only be enabled for commutative and associative operations.（对于combiner不应该有太多的假设，包括消息个数，顺序以及如何进行group的，因此combiner本身的计算应该满足交换律和结合律）

*** Aggregators
   - Pregel aggregators are a mechanism for global communica-tion, monitoring, and data. Each vertex can provide a value to an aggregator in superstep S, the system combines those values using a reduction operator, and the resulting value is made available to all vertices in superstep S + 1. （通过将S的所有节点数据全部聚合起来，然后在S+1散播给所有的节点）
     - Aggregators can be used for statistics. For instance, a sum aggregator applied to the out-degree of each vertex yields the total number of edges in the graph. More complex reduction operators can generate histograms of a statistic.（统计使用，比如计算所有节点的出度，或者是更加复杂的聚合操作可以产生统计指标的直方图等）
     - Aggregators can also be used for global coordination. For instance, one branch of Compute() can be executed for the supersteps until an and aggregator determines that all ver-tices satisfy some condition, and then another branch can be executed until termination. A min or max aggregator, ap-plied to the vertex ID, can be used to select a vertex to play a distinguished role in an algorithm.（全局协调作用。一个节点可以单独选举出来作为其他作用，比如在Vertex id上面做min/max操作来选择一个节点）
   - To define a new aggregator, a user subclasses the pre-defined Aggregator class, and specifies how the aggregated value is initialized from the first input value and how mul-tiple partially aggregated values are reduced to one. Aggre-gation operators should be commutative and associative.（定义一个聚合类非常简单，但是需要注意的是所有input的顺序以及group方式都不确定，和combiner类似，应该满足结合律和交换律）
   - By default an aggregator only reduces input values from a single superstep, but it is also possible to define a sticky aggregator that uses input values from all supersteps. This is useful, for example, for maintaining a global edge count that is adjusted only when edges are added or removed.（默认的聚合操作是针对一个superstep完成的，如何设置成为sticky bit的话，那么这个聚合操作就可以一直存在收集所有superstep的输入）
    
*** Topology Mutations
   - Multiple vertices may issue conflicting requests in the same superstep (e.g., two requests to add a vertex V , with dif-ferent initial values). We use two mechanisms to achieve determinism: partial ordering and handlers.（拓扑结构的修改在同一个superstep可能会出现冲突，比如用一个value创建两个不同的节点），我们通过下面两个机制达到确定性：偏序和handlers
   - 所谓偏序就是定义所有操作的顺序：
     - As with messages, mutations become effective in the su-perstep after the requests were issued. *TODO(dirlt):是什么意思？对于所有的mutations操作都是在request发起之后都会立刻生效。*
     - Within that super-step removals are performed first, with edge removal before vertex removal, since removing a vertex implicitly removes all of its out-edges. Additions follow removals, with ver-tex addition before edge addition,（在一个superstep里面来说，remove首先执行，首先是edge removal，然后是vertex removal，addition后执行，首先是vertex addition，然后是edge addition）
     - and all mutations precede calls to Compute(). This partial ordering yields determinis-tic results for most conflicts. *TODO（dirlt）：这里所说的意思是否指，本次的修改会在下次的compute之前生效。因为按照我们写程序的习惯来说，肯定是一边compute一边计算需要删除和增加哪些顶点和边的）*
   - The remaining conflicts are resolved by user-defined han-dlers. If there are multiple requests to create the same vertex in the same superstep, then by default the system just picks one arbitrarily, but users with special needs may specify a better conflict resolution policy by defining an appropriate handler method in their Vertex subclass. The same handler mechanism is used to resolve conflicts caused by multiple vertex removal requests, or by multiple edge addition or re-moval requests. We delegate the resolution to handlers to keep the code of Compute() simple, which limits the inter-action between a handler and Compute(), but has not been an issue in practice.（如果依然出现冲突的话，那么系统会选择任意节点处理。但是如果用户指定了handler的话，那么可以由用户自己选择一个节点来处理这个冲突问题。） 
   - Our coordination mechanism is lazy: global mutations do not require coordination until the point when they are ap-plied. This design choice facilitates stream processing. The intuition is that conflicts involving modification of a vertex V are handled by V itself. （使用懒协调机制，大部分全局修改不需要协调机制只有当交集的时候。这样适合流处理。直觉上面告诉我们，如果对于V修改出现冲突的话，那么应该是V自身进行处理）
   - Pregel also supports purely local mutations, i.e., a vertex adding or removing its own outgoing edges or removing it-self. Local mutations cannot introduce conflicts and making them immediately effective simplifies distributed program-ming by using an easier sequential programming semantics（对于local修改比如增加出边和减少出边，或者是直接删除自身，因为没有牵扯到冲突所有修改起来非常简单。本地修改也是立刻生效）

*TODO（dirlt）：有个问题就是不太明白，对于修改来说到底是立刻生效，还是仅仅是通知master节点，然后下论生效？partial order是强制还是建议的？*

*** Input and Output
定义了常用的输入输出格式，也提供了读写接口来进行扩展。

** Implementation
** Applications
** Experiments
** Related Work
** Conclusion and Future Work

